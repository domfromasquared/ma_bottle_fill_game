<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MA Bottle Fill Game</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111827;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#38bdf8;
      --accent2:#a78bfa;
      --danger:#fb7185;
      --ok:#34d399;
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.14);
      --shadow:0 16px 50px rgba(0,0,0,.45);
      --radius:18px;
      --radius2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:radial-gradient(1200px 800px at 50% -20%, rgba(56,189,248,.18), transparent 60%),
                 radial-gradient(900px 700px at 120% 120%, rgba(167,139,250,.14), transparent 55%),
                 var(--bg);
      color:var(--text);
      font-family:var(--sans);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }

    /* Phone frame */
    .phone{
      width:min(460px, 100%);
      border:1px solid var(--stroke);
      border-radius:28px;
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:14px 14px 10px;
      border-bottom:1px solid var(--stroke);
      background:rgba(15,23,42,.65);
      backdrop-filter: blur(10px);
      position:sticky;
      top:0;
      z-index:20;
    }
    .brand{
      display:flex;
      gap:10px;
      align-items:center;
      min-width:0;
    }
    .logo{
      width:34px;height:34px;border-radius:11px;
      background:linear-gradient(135deg, rgba(56,189,248,.8), rgba(167,139,250,.75));
      box-shadow:0 10px 28px rgba(56,189,248,.14);
    }
    .brand h1{
      font-size:14px;
      margin:0;
      letter-spacing:.5px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .metaTop{
      display:flex;
      gap:10px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .pill{
      border:1px solid var(--stroke);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      display:flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .mono{font-family:var(--mono)}

    /* HUD */
    .hud{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      padding:10px 14px;
      border-bottom:1px solid var(--stroke);
      background:rgba(17,24,39,.55);
      z-index:10;
    }
    .hudBox{
      border:1px solid var(--stroke);
      border-radius:14px;
      padding:10px 10px;
      background:rgba(0,0,0,.18);
    }
    .hudLabel{
      color:var(--muted);
      font-size:11px;
      margin-bottom:6px;
    }
    .hudValue{
      font-size:16px;
      font-weight:700;
    }

    /* Layout rows */
    .content{
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    /* BANK rail */
    .bankRail{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--stroke);
      border-radius:16px;
      background:rgba(0,0,0,.18);
    }
    .bankLetters{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .bankLetter{
      width:34px;height:34px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      color:rgba(229,231,235,.9);
      background:rgba(255,255,255,.03);
      user-select:none;
    }
    .bankLetter.active{
      border-color:rgba(56,189,248,.65);
      box-shadow:0 0 0 3px rgba(56,189,248,.12);
      color:#fff;
    }
    .bankHint{
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
      max-width:62%;
    }

    /* Modifiers bar */
    .mods{
      border:1px solid var(--stroke);
      border-radius:16px;
      background:rgba(0,0,0,.18);
      padding:10px 12px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      min-height:44px;
    }
    .mods .left{
      display:flex;
      gap:10px;
      align-items:center;
      min-width:0;
    }
    .mods .tag{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--stroke2);
      color:rgba(229,231,235,.92);
      background:rgba(255,255,255,.03);
      white-space:nowrap;
    }
    .mods .desc{
      color:var(--muted);
      font-size:12px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* Controls */
    .controls{
      display:flex;
      gap:10px;
    }
    button{
      border:1px solid var(--stroke2);
      background:rgba(255,255,255,.03);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      font-weight:700;
      font-size:13px;
      cursor:pointer;
      flex:1;
      transition:transform .06s ease, border-color .15s ease, background .15s ease;
    }
    button:active{transform:translateY(1px)}
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    .btnPrimary{
      border-color:rgba(56,189,248,.55);
      background:rgba(56,189,248,.08);
    }
    .btnDanger{
      border-color:rgba(251,113,133,.45);
      background:rgba(251,113,133,.07);
    }

    /* Grid */
    .gameStack.paused .grid{
      pointer-events:none;
      filter: blur(.4px) saturate(.9);
      opacity:.88;
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
      user-select:none;
    }
    .bottle{
      border:1px solid var(--stroke2);
      border-radius:16px;
      background:rgba(0,0,0,.18);
      height:112px;
      padding:10px 8px;
      display:flex;
      flex-direction:column-reverse;
      gap:6px;
      position:relative;
      overflow:hidden;
    }
    .bottle.selected{
      border-color:rgba(167,139,250,.65);
      box-shadow:0 0 0 3px rgba(167,139,250,.12);
    }
    .cell{
      height:16px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
    }
    .cell.fill{
      border-color:rgba(255,255,255,.25);
    }
    .bottleCap{
      position:absolute;
      top:8px; left:8px;
      font-size:10px;
      color:rgba(229,231,235,.55);
      letter-spacing:.25px;
    }

    /* DM card layer */
    .dmLayer{
      position:absolute;
      inset:0;
      display:none;
      z-index:40;
      background:rgba(2,6,23,.72);
      backdrop-filter: blur(10px);
      padding:16px;
    }
    .dmLayer.show{display:flex}
    .dmCard{
      margin:auto;
      width:100%;
      max-width:420px;
      border:1px solid var(--stroke2);
      border-radius:22px;
      background:linear-gradient(180deg, rgba(17,24,39,.92), rgba(15,23,42,.92));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .dmCardHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      border-bottom:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
    }
    .dmCardHeader .title{
      font-weight:800;
      letter-spacing:.4px;
      font-size:13px;
    }
    .dmCardBody{
      padding:14px;
      display:flex;
      gap:12px;
      align-items:flex-start;
    }
    .dmAvatar{
      width:56px;height:56px;border-radius:18px;
      background:linear-gradient(135deg, rgba(251,191,36,.25), rgba(56,189,248,.15));
      border:1px solid var(--stroke2);
      flex:0 0 auto;
    }
    .dmText{
      min-width:0;
    }
    .dmLine{
      margin:0 0 10px;
      color:rgba(229,231,235,.95);
      line-height:1.3;
    }
    .dmLine.muted{color:var(--muted)}
    .dmActions{
      display:flex;
      gap:10px;
      padding:0 14px 14px;
    }

    /* Speech bubble layer (for “DM speaks” UI) */
    .speechLayer{
      position:absolute;
      left:14px; right:14px;
      bottom:14px;
      border:1px solid var(--stroke2);
      border-radius:22px;
      background:linear-gradient(180deg, rgba(17,24,39,.92), rgba(15,23,42,.92));
      box-shadow:var(--shadow);
      padding:14px 14px 12px;
      z-index:35;
      display:none; /* IMPORTANT: will show when .show */
    }
    .speechLayer.show{display:block}
    .speechTitle{
      margin:0 0 8px;
      font-size:13px;
      font-weight:900;
      letter-spacing:.35px;
      color:rgba(255,255,255,.94);
    }
    .speechText{
      margin:0 0 8px;
      color:rgba(229,231,235,.94);
      line-height:1.35;
      font-size:13px;
    }
    .speechText.small{
      color:var(--muted);
      font-size:12px;
    }
    .speechMeta{
      margin-top:10px;
      border-top:1px solid var(--stroke);
      padding-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      font-size:11px;
      color:rgba(229,231,235,.70);
    }
    .meta .mono{color:rgba(229,231,235,.88)}
  </style>
</head>

<body>
  <div class="phone">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <h1>MA Bottle Fill Game</h1>
      </div>
      <div class="metaTop">
        <div class="pill">Level <span id="levelOut" class="mono">1</span></div>
        <div class="pill">Seed <span id="seedOut" class="mono">—</span></div>
      </div>
    </div>

    <div class="hud">
      <div class="hudBox">
        <div class="hudLabel">Moves</div>
        <div class="hudValue mono" id="movesOut">0</div>
      </div>
      <div class="hudBox">
        <div class="hudLabel">Invalid</div>
        <div class="hudValue mono" id="invalidOut">0</div>
      </div>
      <div class="hudBox">
        <div class="hudLabel">Resets</div>
        <div class="hudValue mono" id="resetsOut">0</div>
      </div>
      <div class="hudBox">
        <div class="hudLabel">Status</div>
        <div class="hudValue mono" id="statusHud">ready</div>
      </div>
    </div>

    <div class="content gameStack" id="gameStack">
      <div class="bankRail">
        <div class="bankLetters" aria-label="BANK rail">
          <div class="bankLetter" id="bankB">B</div>
          <div class="bankLetter" id="bankA">A</div>
          <div class="bankLetter" id="bankN">N</div>
          <div class="bankLetter" id="bankK">K</div>
        </div>
        <div class="bankHint" id="bankHint">
          Your play style shapes the DM. Keep pouring — the DM appears every few levels.
        </div>
      </div>

      <div class="mods">
        <div class="left">
          <div class="tag" id="modTag">Modifier</div>
          <div class="desc" id="modDesc">None active.</div>
        </div>
        <div class="mono" id="modShort">—</div>
      </div>

      <div class="controls">
        <button class="btnDanger" id="btnReset">Reset</button>
        <button class="btnPrimary" id="btnNext">Next Level</button>
        <button id="btnQuest" disabled>DM @ L—</button>
      </div>

      <div class="grid" id="grid" aria-label="Bottle grid"></div>
    </div>

    <!-- Speech bubble (shown when DM is speaking) -->
    <section class="speechLayer" id="speechLayer" aria-label="Speech Bubble">
      <h2 class="speechTitle" id="questTitle">—</h2>

      <!-- Actual DM dialogue opener -->
      <p class="speechText" id="dmIntro"></p>

      <!-- System / scheduling text (do NOT overwrite dmIntro anymore) -->
      <p class="speechText small" id="dmStatus"></p>

      <p class="speechText" id="dmMid"></p>
      <p class="speechText" id="dmVerdict"></p>

      <div class="speechMeta">
        <div class="meta">BANK: <span id="bankOut" class="mono">—</span></div>
        <div class="meta">SinTags: <span id="sinsOut" class="mono">—</span></div>
        <div class="meta">DM#: <span id="dmCountOut" class="mono">0</span></div>
        <div class="meta">Next: <span id="nextDmOut" class="mono">—</span></div>
        <div class="meta">Modifier: <span id="modOut" class="mono">—</span></div>
        <div class="meta">Recipe: <span id="recipeSrcOut" class="mono">—</span></div>
        <div class="meta">Status: <span id="statusOut" class="mono">ready</span></div>
      </div>
    </section>

    <!-- Fullscreen DM overlay -->
    <div class="dmLayer" id="dmLayer" aria-label="DM overlay">
      <div class="dmCard">
        <div class="dmCardHeader">
          <div class="title">The Marketing Alchemist</div>
          <button id="dmClose" style="flex:0 0 auto; padding:8px 10px; border-radius:12px;">Close</button>
        </div>
        <div class="dmCardBody">
          <div class="dmAvatar" aria-hidden="true"></div>
          <div class="dmText">
            <p class="dmLine" id="dmCardLine1">…</p>
            <p class="dmLine muted" id="dmCardLine2">…</p>
          </div>
        </div>
        <div class="dmActions">
          <button id="dmOk" class="btnPrimary">Got it</button>
          <button id="dmCopy">Copy</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    /**********************
     * Config / Utilities
     **********************/
    const API_BASE =
      location.hostname === "localhost" || location.hostname === "127.0.0.1"
        ? "http://localhost:8787"
        : "https://ma-bottle-fill-game.onrender.com";

    const CAPACITY_DEFAULT = 4;

    // DM scheduling
    const DM_GAP_MIN = 3;
    const DM_GAP_MAX = 6;
    const DM_MAJOR_EVERY = 5;

    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

    function hashSeed(str) {
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }
    function mulberry32(a) {
      return function() {
        let t = (a += 0x6D2B79F5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    function randInt(rng, a, b) {
      return Math.floor(rng() * (b - a + 1)) + a;
    }

    // basic single-flight for DM calls
    const inflight = new Map();
    function singleFlight(key, fn) {
      if (inflight.has(key)) return inflight.get(key);
      const p = (async () => {
        try { return await fn(); }
        finally { inflight.delete(key); }
      })();
      inflight.set(key, p);
      return p;
    }

    async function postJSON(path, body) {
      const res = await fetch(`${API_BASE}${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body || {})
      });
      if (!res.ok) {
        const retryAfter = res.headers.get("Retry-After");
        let msg = `HTTP ${res.status}`;
        try {
          const data = await res.json();
          msg = data?.error || msg;
        } catch {}
        const err = new Error(msg);
        err.retryAfter = retryAfter;
        throw err;
      }
      return res.json();
    }

    /**********************
     * DOM
     **********************/
    const grid = document.getElementById("grid");
    const gameStack = document.getElementById("gameStack");

    const levelOut = document.getElementById("levelOut");
    const seedOut = document.getElementById("seedOut");
    const movesOut = document.getElementById("movesOut");
    const invalidOut = document.getElementById("invalidOut");
    const resetsOut = document.getElementById("resetsOut");
    const statusHud = document.getElementById("statusHud");

    const btnReset = document.getElementById("btnReset");
    const btnNext = document.getElementById("btnNext");
    const btnQuest = document.getElementById("btnQuest");

    const bankB = document.getElementById("bankB");
    const bankA = document.getElementById("bankA");
    const bankN = document.getElementById("bankN");
    const bankK = document.getElementById("bankK");

    const modTag = document.getElementById("modTag");
    const modDesc = document.getElementById("modDesc");
    const modShort = document.getElementById("modShort");

    const speechLayer = document.getElementById("speechLayer");
    const questTitle = document.getElementById("questTitle");
    const dmIntro = document.getElementById("dmIntro");
    const dmStatus = document.getElementById("dmStatus");
    const dmMid = document.getElementById("dmMid");
    const dmVerdict = document.getElementById("dmVerdict");

    const bankOut = document.getElementById("bankOut");
    const sinsOut = document.getElementById("sinsOut");
    const dmCountOut = document.getElementById("dmCountOut");
    const nextDmOut = document.getElementById("nextDmOut");
    const modOut = document.getElementById("modOut");
    const recipeSrcOut = document.getElementById("recipeSrcOut");
    const statusOut = document.getElementById("statusOut");

    const dmLayer = document.getElementById("dmLayer");
    const dmClose = document.getElementById("dmClose");
    const dmOk = document.getElementById("dmOk");
    const dmCopy = document.getElementById("dmCopy");
    const dmCardLine1 = document.getElementById("dmCardLine1");
    const dmCardLine2 = document.getElementById("dmCardLine2");

    function setStatus(s) {
      statusHud.textContent = s;
      statusOut.textContent = s;
    }

    /**********************
     * Game State
     **********************/
    const sig = { startTime: Date.now(), moves:0, invalid:0, resets:0 };

    const state = {
      level: 1,
      capacity: CAPACITY_DEFAULT,
      bottles: [],
      selected: null,
      lock: false,
      runSeed: null,

      // DM scheduling persistence
      dmAppearCount: 0,
      nextDMAtLevel: 0,

      // Modifier applied to NEXT level
      pendingModifier: null,
      activeModifier: null,

      // debugging
      lastRecipeSource: "local"
    };

    function loadRunState() {
      const seed = localStorage.getItem("runSeed") || null;
      const dmAppearCount = parseInt(localStorage.getItem("dmAppearCount") || "0", 10);
      const nextDMAtLevel = parseInt(localStorage.getItem("nextDMAtLevel") || "0", 10);
      const pendingModifierRaw = localStorage.getItem("pendingModifier");

      state.runSeed = seed || `run_${Date.now()}`;
      state.dmAppearCount = Number.isFinite(dmAppearCount) ? dmAppearCount : 0;
      state.nextDMAtLevel = Number.isFinite(nextDMAtLevel) ? nextDMAtLevel : 0;

      state.pendingModifier = null;
      if (pendingModifierRaw) {
        try { state.pendingModifier = JSON.parse(pendingModifierRaw); } catch {}
      }

      localStorage.setItem("runSeed", state.runSeed);
    }

    function persistRunState() {
      localStorage.setItem("runSeed", state.runSeed);
      localStorage.setItem("dmAppearCount", String(state.dmAppearCount));
      localStorage.setItem("nextDMAtLevel", String(state.nextDMAtLevel));
      localStorage.setItem("pendingModifier", state.pendingModifier ? JSON.stringify(state.pendingModifier) : "");
    }

    /**********************
     * BANK inference (simple + stable)
     **********************/
    function inferBANK() {
      const elapsed = Math.max(1, (Date.now() - sig.startTime) / 1000);
      const pace = sig.moves / elapsed;           // moves per second
      const invalidRate = sig.invalid / Math.max(1, sig.moves);
      const resetRate = sig.resets / Math.max(1, state.level);

      // Simple heuristic mapping: tune later
      // Action: high pace
      // Blueprint: low invalid + structured
      // Nurturing: higher resets (careful) + lower pace
      // Knowledge: lower pace but low invalid
      let scores = { B:0, A:0, N:0, K:0 };
      scores.A += clamp(pace * 6, 0, 6);
      scores.B += clamp((1 - invalidRate) * 4, 0, 4);
      scores.K += clamp((1 - invalidRate) * 3 + (1 - pace) * 2, 0, 5);
      scores.N += clamp(resetRate * 3 + (1 - pace) * 2, 0, 5);

      const entries = Object.entries(scores).sort((a,b)=>b[1]-a[1]);
      const [primary, top] = entries[0];
      const [, second] = entries[1];
      const confidence = clamp((top - second) / 6, 0.15, 0.95);
      return { primary, confidence };
    }

    function inferSinTags() {
      const tags = [];
      const invalidRate = sig.invalid / Math.max(1, sig.moves);
      const elapsed = Math.max(1, (Date.now() - sig.startTime) / 1000);
      const pace = sig.moves / elapsed;

      if (invalidRate > 0.25) tags.push("impatience");
      if (pace < 0.06) tags.push("overthinking");
      if (sig.resets >= 3) tags.push("perfectionism");
      return tags.slice(0, 3);
    }

    function setActiveBankLetter(letter) {
      [bankB, bankA, bankN, bankK].forEach(el => el.classList.remove("active"));
      const map = { B: bankB, A: bankA, N: bankN, K: bankK };
      map[letter]?.classList.add("active");
    }

    /**********************
     * Level generation (local fallback)
     **********************/
    function generateLocalLevel(level, modifier) {
      // Very simple deterministic generator (not perfect, but stable)
      const seed = hashSeed(`${state.runSeed}|L${level}|${JSON.stringify(modifier||{})}`);
      const rng = mulberry32(seed);

      const colors = modifier?.colorCount ? clamp(modifier.colorCount, 3, 8) : clamp(3 + Math.floor(level/3), 3, 8);
      const empties = modifier?.empties ? clamp(modifier.empties, 1, 3) : 2;
      const capacity = modifier?.capacity ? clamp(modifier.capacity, 3, 6) : CAPACITY_DEFAULT;

      state.capacity = capacity;

      // build solved stacks
      const stacks = [];
      for (let c=0; c<colors; c++) {
        const color = `c${c}`;
        stacks.push(Array.from({length: capacity}, ()=>color));
      }
      for (let i=0; i<empties; i++) stacks.push([]);

      // shuffle by pouring chunks around (still solvable)
      const bottles = stacks.map(s => s.slice());
      const steps = 35 + level*3;
      for (let i=0; i<steps; i++) {
        const from = randInt(rng, 0, bottles.length-1);
        const to = randInt(rng, 0, bottles.length-1);
        if (from === to) continue;
        if (!canPour(bottles, from, to, capacity)) continue;
        bottles.splice(0, bottles.length, ...applyPour(bottles, from, to, capacity));
      }

      state.lastRecipeSource = "local";
      return bottles;
    }

    /**********************
     * Core Rules (stable + pure)
     **********************/
    function canPour(bottles, from, to, cap) {
      const src = bottles[from];
      const dst = bottles[to];
      if (!src || !dst) return false;
      if (!src.length) return false;
      if (dst.length >= cap) return false;
      const color = src[src.length - 1];
      if (dst.length && dst[dst.length - 1] !== color) return false;
      return true;
    }

    function applyPour(bottles, from, to, cap) {
      const next = bottles.map(b => b.slice());
      const src = next[from];
      const dst = next[to];
      const color = src[src.length - 1];

      while (src.length && src[src.length - 1] === color && dst.length < cap) {
        dst.push(src.pop());
      }
      return next;
    }

    function isWin(bottles, cap) {
      return bottles.every(b =>
        b.length === 0 ||
        (b.length === cap && b.every(x => x === b[0]))
      );
    }

    /**********************
     * DM Scheduling
     **********************/
    function scheduleNextDM(levelNow) {
      const seed = hashSeed(`${state.runSeed}|DM|${state.dmAppearCount}|L${levelNow}`);
      const rng = mulberry32(seed);
      const gap = randInt(rng, DM_GAP_MIN, DM_GAP_MAX);
      state.nextDMAtLevel = levelNow + gap;
      persistRunState();
    }

    function isDMLevel(level) {
      return level === state.nextDMAtLevel;
    }

    function isMajorDM(upcomingDmNumber) {
      return (upcomingDmNumber % DM_MAJOR_EVERY) === 0;
    }

    function formatModifier(mod) {
      if (!mod) return "—";
      const bits = [];
      if (mod.capacity) bits.push(`cap:${mod.capacity}`);
      if (mod.colorCount) bits.push(`colors:${mod.colorCount}`);
      if (mod.empties) bits.push(`empties:${mod.empties}`);
      if (mod.moveBudget) bits.push(`budget:${mod.moveBudget}`);
      return bits.join(" ") || "—";
    }

    function setPendingModifier(mod) {
      state.pendingModifier = mod || null;
      persistRunState();
    }

    /**********************
     * Render
     **********************/
    function colorToCss(c) {
      // deterministic palette
      const palette = [
        "rgba(56,189,248,.85)",   // cyan
        "rgba(167,139,250,.85)",  // violet
        "rgba(34,197,94,.80)",    // green
        "rgba(251,191,36,.85)",   // amber
        "rgba(244,114,182,.85)",  // pink
        "rgba(248,113,113,.85)",  // red
        "rgba(163,230,53,.85)",   // lime
        "rgba(253,186,116,.85)"   // orange
      ];
      const idx = parseInt(c.replace("c",""), 10);
      return palette[idx % palette.length];
    }

    function renderGrid() {
      grid.innerHTML = "";
      const cap = state.capacity;

      state.bottles.forEach((b, i) => {
        const el = document.createElement("div");
        el.className = "bottle" + (state.selected === i ? " selected" : "");
        el.dataset.i = String(i);

        const capLabel = document.createElement("div");
        capLabel.className = "bottleCap mono";
        capLabel.textContent = `${b.length}/${cap}`;
        el.appendChild(capLabel);

        // cells (bottom up)
        for (let j=0; j<cap; j++) {
          const cell = document.createElement("div");
          cell.className = "cell" + (j < b.length ? " fill" : "");
          if (j < b.length) cell.style.background = colorToCss(b[j]);
          el.appendChild(cell);
        }

        grid.appendChild(el);
      });
    }

    function updateHUD() {
      levelOut.textContent = String(state.level);
      seedOut.textContent = state.runSeed ? String(hashSeed(state.runSeed)).slice(0,6) : "—";
      movesOut.textContent = String(sig.moves);
      invalidOut.textContent = String(sig.invalid);
      resetsOut.textContent = String(sig.resets);

      dmCountOut.textContent = String(state.dmAppearCount);
      nextDmOut.textContent = state.nextDMAtLevel ? `L${state.nextDMAtLevel}` : "—";
      modOut.textContent = formatModifier(state.pendingModifier);
      recipeSrcOut.textContent = state.lastRecipeSource;

      const active = state.activeModifier;
      modShort.textContent = formatModifier(active || state.pendingModifier);
      modDesc.textContent = active
        ? "Active modifier is applied to this level."
        : (state.pendingModifier ? "Pending modifier will affect the NEXT level." : "None active.");

      // bank rail + meta
      const { primary, confidence } = inferBANK();
      setActiveBankLetter(primary);
      bankOut.textContent = `${primary} (${Math.round(confidence*100)}%)`;
      const sins = inferSinTags();
      sinsOut.textContent = sins.length ? sins.join(", ") : "—";
    }

    function updateDMButton() {
      const level = state.level;

      if (!state.nextDMAtLevel || state.nextDMAtLevel < 1) {
        // first schedule
        scheduleNextDM(level);
      }

      if (isDMLevel(level)) {
        const upcoming = state.dmAppearCount + 1;
        const major = isMajorDM(upcoming);
        btnQuest.disabled = false;
        btnQuest.textContent = major ? "Major Ritual (Brew Modifier)" : "DM Speaks";

        dmStatus.textContent = major
          ? "A major ritual is available now. Brew a modifier that affects the NEXT level."
          : "Minor visit: story + directive. No modifier brewed this time.";
      } else {
        btnQuest.disabled = true;
        btnQuest.textContent = `DM @ L${state.nextDMAtLevel}`;
        dmStatus.textContent =
          `DM appears randomly every ${DM_GAP_MIN}–${DM_GAP_MAX} levels. ` +
          `Next appearance: level ${state.nextDMAtLevel}. ` +
          `Modifiers only brew on every ${DM_MAJOR_EVERY}th DM appearance.`;
      }
    }

    function renderAll() {
      renderGrid();
      updateHUD();
      updateDMButton();
    }

    /**********************
     * DM UI helpers
     **********************/
    function openDM() {
      gameStack.classList.add("paused");
      speechLayer.classList.add("show");
      dmLayer.classList.add("show");
    }
    function closeDM() {
      dmLayer.classList.remove("show");
      // keep speech bubble visible as a “log” if you want; or hide it:
      // speechLayer.classList.remove("show");
      gameStack.classList.remove("paused");
    }

    dmClose.addEventListener("click", closeDM);
    dmOk.addEventListener("click", closeDM);

    dmCopy.addEventListener("click", async () => {
      const text = [questTitle.textContent, dmIntro.textContent, dmMid.textContent, dmVerdict.textContent]
        .filter(Boolean).join("\n\n");
      try {
        await navigator.clipboard.writeText(text);
        dmCardLine2.textContent = "Copied.";
      } catch {
        dmCardLine2.textContent = "Copy failed (clipboard blocked).";
      }
    });

    function renderDM(payload) {
      // ✅ FIX: dmIntro is now populated
      questTitle.textContent = payload?.quest_title || "—";
      dmIntro.textContent =
        payload?.dm_intro ||
        payload?.dm_opening ||
        payload?.dm_intro_text ||
        payload?.opening ||
        "";

      dmMid.textContent = payload?.dm_midpoint || payload?.midpoint || "";
      dmVerdict.textContent = payload?.dm_verdict || payload?.verdict || "";

      // also mirror into the overlay card for readability
      dmCardLine1.textContent = dmIntro.textContent || "…";
      dmCardLine2.textContent = dmVerdict.textContent || dmMid.textContent || "…";
    }

    /**********************
     * Game Flow
     **********************/
    function resetLevel() {
      sig.resets++;
      sig.moves = 0;
      sig.invalid = 0;
      sig.startTime = Date.now();
      state.selected = null;

      // Rebuild the same level deterministically
      state.bottles = generateLocalLevel(state.level, state.activeModifier);
      renderAll();
    }

    function nextLevel() {
      state.level++;
      state.selected = null;

      // apply pending modifier ONCE
      state.activeModifier = state.pendingModifier;
      setPendingModifier(null);

      // if the new level is beyond scheduled DM, keep schedule
      state.bottles = generateLocalLevel(state.level, state.activeModifier);
      renderAll();
    }

    function onWin() {
      setStatus("win");
      // auto-advance feel (optional) — keep manual for now
    }

    function onBottleClick(i) {
      if (state.lock) return;

      if (state.selected === null) {
        state.selected = i;
        renderAll();
        return;
      }

      const from = state.selected;
      const to = i;
      state.selected = null;

      if (!canPour(state.bottles, from, to, state.capacity)) {
        sig.invalid++;
        renderAll();
        return;
      }

      // apply move
      state.bottles = applyPour(state.bottles, from, to, state.capacity);
      sig.moves++;

      if (isWin(state.bottles, state.capacity)) onWin();
      setStatus("ready");
      renderAll();
    }

    grid.addEventListener("click", (e) => {
      const bottleEl = e.target.closest(".bottle");
      if (!bottleEl) return;
      const idx = parseInt(bottleEl.dataset.i, 10);
      if (!Number.isFinite(idx)) return;
      onBottleClick(idx);
    });

    btnReset.addEventListener("click", () => {
      resetLevel();
    });

    btnNext.addEventListener("click", () => {
      setStatus("ready");
      nextLevel();
    });

    btnQuest.addEventListener("click", async () => {
      const level = state.level;
      if (!isDMLevel(level)) return;

      // prevent double-click spam
      if (state.lock) return;
      state.lock = true;

      openDM();
      setStatus("dm");
      dmIntro.textContent = "…summoning the DM…";
      dmMid.textContent = "";
      dmVerdict.textContent = "";

      const { primary, confidence } = inferBANK();
      const sinTags = inferSinTags();

      // meta UI
      bankOut.textContent = `${primary} (${Math.round(confidence*100)}%)`;
      sinsOut.textContent = sinTags.length ? sinTags.join(", ") : "—";

      const upcoming = state.dmAppearCount + 1;
      const major = isMajorDM(upcoming);

      try {
        const payload = await singleFlight("quest-node", async () => {
          // Adjust request shape as needed; safe defaults:
          return postJSON("/api/quest-node", {
            level,
            bank_primary: primary,
            bank_confidence: confidence,
            sin_tags: sinTags,
            is_major: major
          });
        });

        // Support both {payload:{...}} and direct payload
        const dmPayload = payload?.payload || payload;

        renderDM(dmPayload);

        // apply modifier only on major DMs (and affects NEXT level)
        const mod = dmPayload?.modifier || dmPayload?.modifier_delta || null;
        if (major && mod) {
          setPendingModifier(mod);
        }

        // increment DM appearance count + schedule next DM
        state.dmAppearCount++;
        scheduleNextDM(level);
        renderAll();

      } catch (err) {
        dmIntro.textContent = "The DM choked on the incense. Try again.";
        dmVerdict.textContent = err?.message || "DM error.";
        dmCardLine1.textContent = dmIntro.textContent;
        dmCardLine2.textContent = dmVerdict.textContent;
      } finally {
        state.lock = false;
        setStatus("ready");
      }
    });

    /**********************
     * Boot
     **********************/
    function boot() {
      loadRunState();
      if (!state.nextDMAtLevel) scheduleNextDM(state.level);

      state.activeModifier = null;
      state.bottles = generateLocalLevel(state.level, state.activeModifier);

      setStatus("ready");
      renderAll();
    }
    boot();
  </script>
</body>
</html>
