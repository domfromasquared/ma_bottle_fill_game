<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Marketing Alchemist â€” Bottle Fill (Quest DM)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f14; color:#e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; display:flex; flex-direction:column; gap:14px; }
    .card { border:1px solid #243244; border-radius: 18px; background: linear-gradient(180deg,#0f1724,#0b121c); box-shadow: 0 20px 50px rgba(0,0,0,.25); overflow:hidden; }
    .cardHeader { display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid #1e2a3c; }
    .title { font-size: 34px; font-weight: 800; letter-spacing: -0.5px; display:flex; align-items:center; gap:10px;}
    .pill { border:1px solid #243244; border-radius: 999px; padding: 8px 12px; background:#0b121c; display:inline-flex; align-items:center; gap:10px; }
    .pill input { width: 360px; max-width: 56vw; background: transparent; border: none; outline: none; color:#e6edf3; font: inherit; }
    button { cursor:pointer; border:1px solid #243244; background:#111a27; color:#e6edf3; border-radius: 14px; padding: 10px 14px; font-weight: 700; }
    button:disabled { opacity: .55; cursor:not-allowed; }
    .content { padding: 18px 16px; }
    h2 { margin: 0 0 10px 0; font-size: 36px; letter-spacing: -0.5px; }
    p { margin: 0 0 10px 0; font-size: 26px; line-height: 1.22; color:#d7deea; }
    .metaRow { display:flex; flex-wrap:wrap; gap:10px; margin-top:14px; }
    .meta { display:inline-flex; align-items:center; gap:10px; border:1px solid #243244; border-radius: 999px; padding: 10px 12px; background:#0b121c; font-size: 20px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 16px; color:#aab6ca; }
    .split { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .gameHeader { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .stats { display:flex; gap:10px; flex-wrap:wrap; }
    .grid { display:flex; flex-wrap:wrap; gap:16px; padding: 18px 16px; min-height: 300px; }
    .bottle {
      width: 84px; height: 220px;
      border-radius: 22px 22px 26px 26px;
      border: 2px solid rgba(220,232,255,.14);
      background: rgba(0,0,0,.25);
      position:relative;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.03);
      display:flex; flex-direction:column-reverse;
      overflow:hidden;
      user-select:none;
      touch-action: manipulation;
      transform: translateZ(0);
    }
    .bottle::before {
      content:"";
      position:absolute; inset: 10px 10px 10px 10px;
      border-radius: 18px 18px 22px 22px;
      border:1px solid rgba(255,255,255,.06);
      pointer-events:none;
    }
    .bottle.selected { outline: 3px solid rgba(130, 210, 255,.45); box-shadow: 0 0 0 6px rgba(80,140,255,.12), inset 0 0 0 2px rgba(255,255,255,.04); }
    .seg { width:100%; height: 22%; }
    .controls { display:flex; gap:10px; padding: 0 16px 16px 16px; flex-wrap:wrap; }
    .toast { position: fixed; left: 50%; bottom: 22px; transform: translateX(-50%); background:#0b121c; border:1px solid #243244; border-radius: 999px; padding: 10px 14px; font-weight:700; opacity:0; transition: opacity .18s ease; pointer-events:none;}
    .toast.show { opacity:1; }
    .pourFX {
      position: fixed; width: 10px; height: 10px; border-radius: 999px;
      pointer-events:none;
      opacity:0;
      transform: translate(-50%, -50%);
      filter: blur(.2px);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="dmCard">
      <div class="cardHeader">
        <div class="title">ðŸ§ª The Marketing Alchemist <span style="opacity:.7">(Quest DM)</span></div>
        <div class="split">
          <div class="pill">
            <span style="opacity:.7">API:</span>
            <input id="apiBase" class="mono" />
          </div>
          <button id="btnQuest">Quest Node</button>
        </div>
      </div>
      <div class="content">
        <h2 id="questTitle">â€”</h2>
        <p id="dmIntro" class="small">Quest Nodes are brewed ONLY on every <b>5th level</b> (5, 10, 15â€¦).</p>
        <p id="dmMid" class="small"></p>
        <p id="dmVerdict" class="small"></p>

        <div class="metaRow">
          <div class="meta">B.A.N.K: <span id="bankOut" class="mono">â€”</span></div>
          <div class="meta">SinTags: <span id="sinsOut" class="mono">â€”</span></div>
          <div class="meta">Modifier: <span id="modOut" class="mono">â€”</span></div>
          <div class="meta">Recipe: <span id="recipeSrcOut" class="mono">â€”</span></div>
          <div class="meta">Status: <span id="statusOut" class="mono">ready</span></div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="cardHeader gameHeader">
        <div class="title" style="font-size:28px">Bottle Fill</div>
        <div class="stats">
          <div class="meta">Level: <span id="levelOut" class="mono">1</span></div>
          <div class="meta">Moves: <span id="movesOut" class="mono">0</span></div>
          <div class="meta">Invalid: <span id="badOut" class="mono">0</span></div>
          <div class="meta">Resets: <span id="resetOut" class="mono">0</span></div>
          <div class="meta">Cfg: <span id="cfgOut" class="mono">â€”</span></div>
          <div class="meta small">Tap bottle â†’ tap target. Satisfying pour.</div>
        </div>
      </div>
      <div class="grid" id="grid"></div>
      <div class="controls">
        <button id="btnNext">Next Level</button>
        <button id="btnReset">Reset Run</button>
        <div class="meta small">LLM only runs on level 5/10/15â€¦ Filler levels are deterministic.</div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="pourFX" id="pourFX"></div>

<script type="module">
  const DEFAULT_PROD = "https://ma-bottle-fill-api.onrender.com";
  const DEFAULT_LOCAL = "http://localhost:8787";
  const isLocal = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  const apiBaseEl = document.getElementById("apiBase");
  apiBaseEl.value = isLocal ? DEFAULT_LOCAL : DEFAULT_PROD;

  const inflight = new Map();
  function singleFlight(key, fn) {
    if (inflight.has(key)) return inflight.get(key);
    const p = (async () => { try { return await fn(); } finally { inflight.delete(key); } })();
    inflight.set(key, p);
    return p;
  }

  let cooldownUntil = 0;
  function canCallNow() { return Date.now() >= cooldownUntil; }
  function setCooldown(ms=2500) { cooldownUntil = Date.now() + ms; }

  const statusOut = document.getElementById("statusOut");
  const questTitle = document.getElementById("questTitle");
  const dmIntro = document.getElementById("dmIntro");
  const dmMid = document.getElementById("dmMid");
  const dmVerdict = document.getElementById("dmVerdict");
  const bankOut = document.getElementById("bankOut");
  const sinsOut = document.getElementById("sinsOut");
  const modOut = document.getElementById("modOut");
  const cfgOut = document.getElementById("cfgOut");
  const recipeSrcOut = document.getElementById("recipeSrcOut");

  const toast = document.getElementById("toast");
  function showToast(msg) {
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(()=>toast.classList.remove("show"), 1400);
  }

  let runSeed = Math.floor(Math.random() * 1e9);
  let questId = 1;
  let level = 1;

  let pendingModifier = null;
  let anchorRecipe = null;
  let anchorLevel = 0;

  const sig = { moves:0, invalid:0, resets:0, moveTimes:[], lastMoveAt:0 };
  const avg = (arr)=> arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;

  function inferBANK() {
    const pace = avg(sig.moveTimes.slice(-12));
    const invalidRate = sig.moves ? (sig.invalid / sig.moves) : 0;
    const resetRate = sig.resets ? (sig.resets / Math.max(1, level)) : 0;

    const score = { B:0, A:0, N:0, K:0 };
    score.B += pace > 1400 ? 1.2 : 0;
    score.B += invalidRate < 0.10 ? 1.0 : 0;

    score.A += pace && pace < 900 ? 1.2 : 0;
    score.A += invalidRate < 0.22 ? 0.5 : 0;

    score.N += resetRate > 0.30 ? 1.0 : 0;
    score.N += invalidRate > 0.18 ? 0.6 : 0;

    score.K += invalidRate > 0.12 ? 0.7 : 0;
    score.K += resetRate < 0.25 ? 0.7 : 0;

    const entries = Object.entries(score).sort((a,b)=>b[1]-a[1]);
    const [bankPrimary, top] = entries[0];
    const second = entries[1][1];
    const conf = Math.max(0.25, Math.min(0.92, 0.35 + (top-second)*0.55));
    return { bankPrimary, bankConfidence: Number(conf.toFixed(2)) };
  }

  function inferSinTags() {
    const tags = [];
    if (sig.resets >= 2 && sig.resets > level/2) tags.push("over_reset");
    const pace = avg(sig.moveTimes.slice(-12));
    if (pace > 1500) tags.push("hesitation");
    if ((sig.moves && sig.invalid/sig.moves > 0.18)) tags.push("indecision");
    if (!tags.length) tags.push("steady_hand");
    return tags.slice(0,3);
  }

  function formatMod(mod) {
    if (!mod) return "â€”";
    const parts = [];
    const map = [
      ["bottleCountDelta","bottles"],
      ["colorsDelta","colors"],
      ["capacityDelta","cap"],
      ["emptyBottlesDelta","empty"],
      ["lockedBottlesDelta","locks"],
      ["wildcardSlotsDelta","wild"],
    ];
    for (const [k,label] of map) {
      const v = mod[k] ?? 0;
      if (v) parts.push(`${label}${v>0?"+":""}${v}`);
    }
    const tag = mod.ruleTag && mod.ruleTag !== "none" ? mod.ruleTag : "";
    return (parts.length ? parts.join(" ") : "no-delta") + (tag ? ` | ${tag}` : "");
  }

  function setPendingModifier(mod) {
    pendingModifier = mod;
    modOut.textContent = formatMod(mod);
  }

  // Cadence
  const QUEST_EVERY = 5; // ONLY call LLM every 5th level
  function isLLMLevel(lvl) { return (lvl % QUEST_EVERY) === 0; }
  function nextLLMLevel(lvl) { return lvl + ((QUEST_EVERY - (lvl % QUEST_EVERY)) % QUEST_EVERY || QUEST_EVERY); }

  // Deterministic RNG
  function mulberry32(a) {
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }
  function hashSeed(a,b,c){
    let x = (a|0) ^ ((b|0)*0x9E3779B1) ^ ((c|0)*0x85EBCA77);
    x = Math.imul(x ^ (x>>>16), 0x7feb352d);
    x = Math.imul(x ^ (x>>>15), 0x846ca68b);
    x = x ^ (x>>>16);
    return x >>> 0;
  }
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));

  function applyModifier(recipe, mod) {
    if (!mod) return { recipe, consumed:false };
    recipe.bottleCount = clamp(recipe.bottleCount + (mod.bottleCountDelta||0), 6, 14);
    recipe.colors      = clamp(recipe.colors + (mod.colorsDelta||0), 4, 10);
    recipe.capacity    = clamp(recipe.capacity + (mod.capacityDelta||0), 3, 6);
    recipe.emptyBottles= clamp(recipe.emptyBottles + (mod.emptyBottlesDelta||0), 1, 6);
    recipe.lockedBottles = clamp(recipe.lockedBottles + (mod.lockedBottlesDelta||0), 0, 3);
    recipe.wildcardSlots = clamp(recipe.wildcardSlots + (mod.wildcardSlotsDelta||0), 0, 2);
    recipe.emptyBottles = Math.min(recipe.emptyBottles, Math.max(1, recipe.bottleCount - 1));
    recipe.appliedModifier = mod;
    return { recipe, consumed:true };
  }

  function makeFillerRecipe() {
    const { bankPrimary } = inferBANK();
    const sinTags = inferSinTags();
    const seed = hashSeed(runSeed, level, questId);
    const rnd = mulberry32(seed);

    const targetDifficulty = clamp(1 + Math.floor(level / 3) + Math.floor(rnd()*2), 1, 10);

    const base = anchorRecipe ? structuredClone(anchorRecipe) : {
      version: "local-filler",
      title: "Filler Brew",
      lore: "A steady experiment. No theatrics. Just results.",
      difficulty: targetDifficulty,
      colors: 5,
      bottleCount: 10,
      capacity: 4,
      emptyBottles: 2,
      lockedBottles: 0,
      wildcardSlots: 0,
      elements: ["Au","Fe","Na","Cl","C"],
      sinTags: [],
      bonuses: [],
      constraints: [],
      appliedModifier: {
        lockedBottlesDelta:0, emptyBottlesDelta:0, capacityDelta:0,
        wildcardSlotsDelta:0, colorsDelta:0, bottleCountDelta:0,
        ruleTag:"none", bonusObjective:""
      }
    };

    const wobble = (v, min, max, step=1) => clamp(v + (rnd()<0.33?-step:(rnd()>0.66?step:0)), min, max);

    base.version = "local-filler";
    base.difficulty = targetDifficulty;
    base.colors = wobble(clamp(4 + Math.floor(level/4), 4, 10), 4, 10, 1);
    base.capacity = wobble(4 + (level>=18?1:0) + (level>=32?1:0), 3, 6, 1);
    base.emptyBottles = clamp(2 + (rnd()<0.2?1:0) - (rnd()>0.9?1:0), 1, 6);
    base.bottleCount = clamp(base.colors + base.emptyBottles + 3 + Math.floor(rnd()*2), 6, 14);
    base.lockedBottles = clamp((level>=20?1:0) + (rnd()<0.08?1:0), 0, 3);
    base.wildcardSlots = clamp((level>=25 && rnd()<0.15)?1:0, 0, 2);

    base.sinTags = sinTags;
    base.title = `Filler: ${bankPrimary} Distillation`;
    base.lore = `A controlled run. You don't need fireworksâ€”just cleaner pours.`;

    const pool = ["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Fe","Cu","Zn","Ag","Au"];
    const start = Math.floor(rnd()* (pool.length - base.colors));
    base.elements = pool.slice(start, start + base.colors);

    return base;
  }

  async function postJSON(path, body) {
    const base = apiBaseEl.value.trim().replace(/\/+$/, "");
    const url = base + path;
    const r = await fetch(url, { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body) });
    if (!r.ok) {
      let detailText = "";
      try { detailText = await r.text(); } catch {}
      const retryAfter = r.headers.get("Retry-After");
      const err = new Error(`${r.status} ${r.statusText}${retryAfter ? ` (Retry-After: ${retryAfter}s)` : ""}`);
      err.status = r.status;
      err.retryAfter = retryAfter ? Number(retryAfter) : null;
      err.detailText = detailText;
      throw err;
    }
    return await r.json();
  }

  const btnQuest = document.getElementById("btnQuest");

  function updateQuestButton() {
    if (isLLMLevel(level)) {
      btnQuest.disabled = false;
      btnQuest.textContent = "Quest Node";
      dmIntro.textContent = "Quest Node is available now. Brew it and the modifier affects the NEXT level.";
    } else {
      btnQuest.disabled = true;
      const n = nextLLMLevel(level);
      btnQuest.textContent = `Quest @ L${n}`;
      dmIntro.textContent = `Quest Nodes are brewed only on every 5th level. Next brew: level ${n}.`;
    }
  }

  async function brewQuestNode() {
    const { bankPrimary, bankConfidence } = inferBANK();
    const sinTags = inferSinTags();
    bankOut.textContent = `${bankPrimary} (${bankConfidence})`;
    sinsOut.textContent = sinTags.join(", ");

    statusOut.textContent = "brewing...";
    const payload = { act: Math.ceil(level/5), questId, bankPrimary, bankConfidence, sinTags, seed: runSeed, level };
    const data = await postJSON("/api/quest-node", payload);
    const q = data.payload;

    questTitle.textContent = q.quest_title;
    dmMid.textContent = q.dm_midpoint;
    dmVerdict.textContent = q.dm_verdict;

    setPendingModifier(q.modifier);
    statusOut.textContent = "ok";
    showToast("Modifier brewed for next level");
  }

  btnQuest.addEventListener("click", async () => {
    if (!isLLMLevel(level)) return;
    if (!canCallNow()) return;
    setCooldown(2500);

    try {
      await singleFlight(`quest-node:${runSeed}:${questId}:${level}`, brewQuestNode);
    } catch (e) {
      if (e.status === 429) {
        const ms = (e.retryAfter ? e.retryAfter*1000 : 20000);
        setCooldown(ms);
        statusOut.textContent = "rate-limited";
        showToast("Rate limited. Brewing cooldownâ€¦");
      } else {
        statusOut.textContent = "quest error";
        showToast("Quest error (check server).");
      }
      console.warn(e, e.detailText);
    }
  });

  // Game
  const grid = document.getElementById("grid");
  const levelOut = document.getElementById("levelOut");
  const movesOut = document.getElementById("movesOut");
  const badOut = document.getElementById("badOut");
  const resetOut = document.getElementById("resetOut");
  const pourFX = document.getElementById("pourFX");

  const PALETTE = ["#00D1FF","#FF4D6D","#FFD400","#7CFF6B","#A855F7","#FF8A00","#00FFA8","#2E5BFF","#FF3DF2","#C2FF00"];
  const state = { bottles:[], capacity:4, selected:-1 };

  function isSolved() {
    return state.bottles.every(b => {
      if (b.length === 0) return true;
      if (b.length !== state.capacity) return false;
      return b.every(x => x === b[0]);
    });
  }
  const topColor = (b)=> b.length ? b[b.length-1] : null;
  function topRunCount(b){
    if (!b.length) return 0;
    const c = topColor(b);
    let n=0; for(let i=b.length-1;i>=0;i--){ if (b[i]===c) n++; else break; }
    return n;
  }
  function canPour(from,to){
    if (from===to) return false;
    const a=state.bottles[from], b=state.bottles[to];
    if (!a.length) return false;
    if (b.length>=state.capacity) return false;
    const color=topColor(a), target=topColor(b);
    return (target===null || target===color);
  }
  function bottleCenter(i){
    const el=document.querySelector(`[data-bottle="${i}"]`);
    if(!el) return {x:innerWidth/2,y:innerHeight/2};
    const r=el.getBoundingClientRect();
    return {x:r.left+r.width/2, y:r.top+r.height/4};
  }
  function playPourFX(from,to,color,amount){
    const a=bottleCenter(from), b=bottleCenter(to);
    pourFX.style.background=color;
    pourFX.style.opacity="1";
    pourFX.style.left=a.x+"px"; pourFX.style.top=a.y+"px";
    const dx=b.x-a.x, dy=b.y-a.y;
    const dur=Math.max(260, Math.min(580, 220+amount*90));
    pourFX.animate([
      { transform:"translate(-50%,-50%) scale(1)", opacity:0.9 },
      { transform:`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.9)`, opacity:0.85 },
      { transform:`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.7)`, opacity:0.0 }
    ], { duration:dur, easing:"cubic-bezier(.2,.8,.2,1)" });
    setTimeout(()=> pourFX.style.opacity="0", dur);
  }
  function doPour(from,to){
    if(!canPour(from,to)){
      sig.invalid++; badOut.textContent=String(sig.invalid);
      showToast("Invalid pour");
      return false;
    }
    const a=state.bottles[from], b=state.bottles[to];
    const color=topColor(a);
    const run=topRunCount(a);
    const space=state.capacity-b.length;
    const amount=Math.min(run,space);

    const now=performance.now();
    if(sig.lastMoveAt) sig.moveTimes.push(now-sig.lastMoveAt);
    sig.lastMoveAt=now;

    playPourFX(from,to,PALETTE[color%PALETTE.length], amount);
    for(let i=0;i<amount;i++) b.push(a.pop());

    sig.moves++; movesOut.textContent=String(sig.moves);
    render();

    if(isSolved()){
      showToast("Solved! Next levelâ€¦");
      setTimeout(()=>nextLevel(), 700);
    }
    return true;
  }
  const countEmpty = ()=> state.bottles.filter(b=>b.length===0).length;

  function render(){
    grid.innerHTML="";
    state.bottles.forEach((b,i)=>{
      const bottle=document.createElement("div");
      bottle.className="bottle"+(state.selected===i?" selected":"");
      bottle.dataset.bottle=String(i);

      for(let s=0;s<state.capacity;s++){
        const seg=document.createElement("div");
        seg.className="seg";
        const ci = b[s] ?? null;
        seg.style.background = (ci===null) ? "transparent" : PALETTE[ci%PALETTE.length];
        bottle.appendChild(seg);
      }

      bottle.addEventListener("click", ()=>{
        if(state.selected===-1){ state.selected=i; render(); return; }
        if(state.selected===i){ state.selected=-1; render(); return; }
        const success=doPour(state.selected,i);
        state.selected=-1;
        if(!success) render();
      });

      grid.appendChild(bottle);
    });

    levelOut.textContent=String(level);
    movesOut.textContent=String(sig.moves);
    badOut.textContent=String(sig.invalid);
    resetOut.textContent=String(sig.resets);
    cfgOut.textContent=`b${state.bottles.length}/c${state.capacity}/e${countEmpty()}`;
    updateQuestButton();
  }

  function shuffle(arr, rnd=Math.random){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(rnd()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function buildBoardFromRecipe(recipe){
    const colors=recipe.colors, bottles=recipe.bottleCount, cap=recipe.capacity, empty=recipe.emptyBottles;
    const rnd = mulberry32(hashSeed(runSeed, level, 1337));

    const colorStacks=[];
    for(let c=0;c<colors;c++) colorStacks.push(Array.from({length:cap}, ()=>c));

    const pool=shuffle(colorStacks.flat(), rnd);
    const board=Array.from({length:bottles}, ()=>[]);
    const fillCount=bottles-empty;
    let idx=0;
    for(let b=0;b<fillCount;b++){
      for(let s=0;s<cap;s++){
        if(idx<pool.length) board[b].push(pool[idx++]);
      }
    }

    state.capacity=cap;
    state.bottles=board;
    state.selected=-1;

    const scramble = Math.max(40, Math.min(260, recipe.difficulty*24 + 60));
    for(let k=0;k<scramble;k++){
      const a=Math.floor(rnd()*bottles);
      const t=Math.floor(rnd()*bottles);
      if(a===t) continue;
      if(!canPour(a,t)) continue;
      const from=state.bottles[a], to=state.bottles[t];
      if(!from.length || to.length>=cap) continue;
      const col=topColor(from), tgt=topColor(to);
      if(tgt!==null && tgt!==col) continue;
      to.push(from.pop());
    }
  }

  async function fetchLLMRecipe() {
    const { bankPrimary, bankConfidence } = inferBANK();
    const sinTags = inferSinTags();

    const payload = { act: Math.ceil(level/5), questId, bankPrimary, bankConfidence, sinTags, seed: runSeed, level, modifier: pendingModifier };

    statusOut.textContent = "distilling...";
    const data = await postJSON("/api/level-recipe", payload);
    statusOut.textContent = "ok";
    recipeSrcOut.textContent = "LLM";
    return data.recipe;
  }

  function loadFillerRecipe() {
    statusOut.textContent = "local filler";
    recipeSrcOut.textContent = "FILLER";
    return makeFillerRecipe();
  }

  async function loadLevel() {
    let recipe;
    if (isLLMLevel(level)) {
      recipe = await singleFlight(`llm-recipe:${runSeed}:${questId}:${level}`, async () => {
        try {
          const r = await fetchLLMRecipe();
          anchorRecipe = structuredClone(r);
          anchorLevel = level;
          return r;
        } catch (e) {
          if (e.status === 429) {
            const ms = (e.retryAfter ? e.retryAfter*1000 : 20000);
            setCooldown(ms);
            statusOut.textContent = "rate-limited";
            showToast("Rate limited. Using deterministic filler.");
          } else {
            statusOut.textContent = "recipe error";
            showToast("Recipe error. Using deterministic filler.");
          }
          console.warn(e, e.detailText);
          return loadFillerRecipe();
        }
      });
    } else {
      recipe = loadFillerRecipe();
    }

    const applied = applyModifier(recipe, pendingModifier);
    if (applied.consumed) {
      showToast("Modifier consumed");
      setPendingModifier(null);
    } else {
      recipe.appliedModifier = recipe.appliedModifier || {
        lockedBottlesDelta:0, emptyBottlesDelta:0, capacityDelta:0,
        wildcardSlotsDelta:0, colorsDelta:0, bottleCountDelta:0,
        ruleTag:"none", bonusObjective:""
      };
    }

    buildBoardFromRecipe(recipe);
    render();
  }

  function nextLevel(){
    level++;
    questId = Math.ceil(level/4);
    sig.moves=0; sig.invalid=0; sig.moveTimes=[]; sig.lastMoveAt=0;
    loadLevel();
  }

  function resetRun(){
    sig.resets++;
    runSeed = Math.floor(Math.random()*1e9);
    level=1; questId=1;
    sig.moves=0; sig.invalid=0; sig.moveTimes=[]; sig.lastMoveAt=0;
    setPendingModifier(null);
    anchorRecipe=null; anchorLevel=0;
    showToast("Run reset");
    loadLevel();
  }

  document.getElementById("btnNext").addEventListener("click", ()=>nextLevel());
  document.getElementById("btnReset").addEventListener("click", ()=>resetRun());

  updateQuestButton();
  recipeSrcOut.textContent = "â€”";
  loadLevel();
</script>
</body>
</html>
