<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Marketing Alchemist â€” Bottle Fill (Quest DM)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f14; color:#e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; display:flex; flex-direction:column; gap:14px; }
    .card { border:1px solid #243244; border-radius: 18px; background: linear-gradient(180deg,#0f1724,#0b121c); box-shadow: 0 20px 50px rgba(0,0,0,.25); overflow:hidden; }
    .cardHeader { display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid #1e2a3c; }
    .title { font-size: 32px; font-weight: 900; letter-spacing: -0.5px; display:flex; align-items:center; gap:10px;}
    .pill { border:1px solid #243244; border-radius: 999px; padding: 8px 12px; background:#0b121c; display:inline-flex; align-items:center; gap:10px; }
    .pill input { width: 360px; max-width: 56vw; background: transparent; border: none; outline: none; color:#e6edf3; font: inherit; }
    button { cursor:pointer; border:1px solid #243244; background:#111a27; color:#e6edf3; border-radius: 14px; padding: 10px 14px; font-weight: 800; }
    button:disabled { opacity: .55; cursor:not-allowed; }
    .content { padding: 18px 16px; }
    h2 { margin: 0 0 10px 0; font-size: 34px; letter-spacing: -0.5px; }
    p { margin: 0 0 10px 0; font-size: 20px; line-height: 1.25; color:#d7deea; }
    .metaRow { display:flex; flex-wrap:wrap; gap:10px; margin-top:14px; }
    .meta { display:inline-flex; align-items:center; gap:10px; border:1px solid #243244; border-radius: 999px; padding: 10px 12px; background:#0b121c; font-size: 16px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 14px; color:#aab6ca; }
    .split { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .gameHeader { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .stats { display:flex; gap:10px; flex-wrap:wrap; }
    .grid { display:flex; flex-wrap:wrap; gap:16px; padding: 18px 16px; min-height: 300px; }

    .bottle {
      width: 84px; height: 220px;
      border-radius: 22px 22px 26px 26px;
      border: 2px solid rgba(220,232,255,.14);
      background: rgba(0,0,0,.25);
      position:relative;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.03);
      display:flex; flex-direction:column-reverse;
      overflow:hidden;
      user-select:none;
      touch-action: manipulation;
      transform: translateZ(0);
    }
    .bottle::before {
      content:"";
      position:absolute; inset: 10px 10px 10px 10px;
      border-radius: 18px 18px 22px 22px;
      border:1px solid rgba(255,255,255,.06);
      pointer-events:none;
    }
    .bottle.selected { outline: 3px solid rgba(130, 210, 255,.45); box-shadow: 0 0 0 6px rgba(80,140,255,.12), inset 0 0 0 2px rgba(255,255,255,.04); }

    .seg {
      width:100%;
      height: 22%;
      position: relative;
      overflow: hidden;
    }

    /* --------- SVG Pattern Overlay (Role-Based) ---------
       NOTE: Paths verified from repo:
       /assets/pattern_*.svg and /assets/elements/textures/pattern_*.svg
    */
    .seg::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:.56;
      background-size:64px 64px;
      background-repeat:repeat;
      mix-blend-mode: screen;
    }

    /* Default role mappings */
.seg.role-volatile::after   { background-image: url("./assets/elements/textures/pattern_ripples.svg"); animation: drift 7s linear infinite; }
.seg.role-catalyst::after   { background-image: url("./assets/elements/textures/pattern_streaks.svg"); animation: drift 6s linear infinite; }
.seg.role-stabilizer::after { background-image: url("./assets/elements/textures/pattern_noise.svg"); opacity:.36; }
.seg.role-structural::after,
.seg.role-foundational::after { background-image: url("./assets/elements/textures/pattern_grid.svg"); opacity:.44; }
.seg.role-transmission::after,
.seg.role-conversion::after { background-image: url("./assets/elements/textures/pattern_chevrons.svg"); opacity:.44; }

/* Element-specific overrides (optional, improves readability on similar colors) */
.seg.el-EM::after { background-image: url("./assets/elements/textures/pattern_bubbles.svg"); opacity:.52; animation: drift 8s linear infinite; }
.seg.el-CO::after,
.seg.el-DI::after { background-image: url("./assets/elements/textures/pattern_hatch.svg"); opacity:.44; }

/* Motion is subtle; respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  .seg::after{ animation:none !important; }
}
@keyframes drift {
  from { background-position: 0 0; }
  to   { background-position: 64px 64px; }
}

    .controls { display:flex; gap:10px; padding: 0 16px 16px 16px; flex-wrap:wrap; align-items:center;}
    .toast { position: fixed; left: 50%; bottom: 22px; transform: translateX(-50%); background:#0b121c; border:1px solid #243244; border-radius: 999px; padding: 10px 14px; font-weight:800; opacity:0; transition: opacity .18s ease; pointer-events:none;}
    .toast.show { opacity:1; }
    .pourFX {
      position: fixed; width: 10px; height: 10px; border-radius: 999px;
      pointer-events:none;
      opacity:0;
      transform: translate(-50%, -50%);
      filter: blur(.2px);
    }
    .dmStatus {
      margin-top: 2px;
      color:#aab6ca;
      font-size: 14px;
      line-height: 1.2;
    }

    /* ---------- Lab Legend (chemical meaning) ---------- */
    .legend {
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      padding: 10px 16px 0 16px;
    }
    .legendItem{
      display:flex;
      align-items:center;
      gap:10px;
      border:1px solid #243244;
      border-radius: 999px;
      padding: 8px 10px;
      background:#0b121c;
    }
    .swatch{
      width:14px;
      height:14px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
    }
    .legendText{
      display:flex;
      flex-direction:column;
      line-height:1.05;
    }
    .legendTop{
      font-weight:900;
      font-size:13px;
    }
    .legendSub{
      font-size:12px;
      color:#aab6ca;
    }
    .thesisPill{
      border:1px dashed #2a3a52;
      background: rgba(17,26,39,.55);
    }

    /* ---------- Stabilizer Bottle (locked/hidden) ---------- */
    .bottle.locked {
      opacity: .55;
      filter: saturate(.7);
      outline: 2px dashed rgba(200,220,255,.18);
    }
    .bottle.locked::after{
      content:"ðŸ”’ STABILIZER";
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      font-weight: 900;
      font-size: 12px;
      letter-spacing: .5px;
      color: rgba(230,237,243,.9);
      background: rgba(11,18,28,.85);
      border: 1px solid rgba(36,50,68,.9);
      padding: 6px 10px;
      border-radius: 999px;
    }
    .bottle.hiddenSegs .seg { background: transparent !important; }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- DM / Quest Card -->
    <div class="card" id="dmCard">
      <div class="cardHeader">
        <div class="title">ðŸ§ª The Marketing Alchemist <span style="opacity:.7">(Quest DM)</span></div>
        <div class="split">
          <div class="pill">
            <span style="opacity:.7">API:</span>
            <input id="apiBase" class="mono" />
          </div>
          <button id="btnQuest">DM</button>
        </div>
      </div>

      <div class="content">
        <h2 id="questTitle">â€”</h2>

        <!-- DM dialogue -->
        <p id="dmIntro"></p>

        <!-- Scheduling / system copy -->
        <p id="dmStatus" class="dmStatus"></p>

        <p id="dmMid" class="small"></p>
        <p id="dmVerdict" class="small"></p>

        <div class="metaRow">
          <div class="meta">BANK: <span id="bankOut" class="mono">â€”</span></div>
          <div class="meta">SinTags: <span id="sinsOut" class="mono">â€”</span></div>
          <div class="meta">DM#: <span id="dmCountOut" class="mono">0</span> <span class="small">(major on #5, #10...)</span></div>
          <div class="meta">Next DM: <span id="nextDmOut" class="mono">â€”</span></div>
          <div class="meta">Modifier: <span id="modOut" class="mono">â€”</span></div>
          <div class="meta">Recipe: <span id="recipeSrcOut" class="mono">â€”</span></div>
          <div class="meta">Status: <span id="statusOut" class="mono">ready</span></div>
        </div>
      </div>
    </div>

    <!-- Game Card -->
    <div class="card">
      <div class="cardHeader gameHeader">
        <div class="title" style="font-size:26px">Bottle Fill</div>
        <div class="stats">
          <div class="meta">Level: <span id="levelOut" class="mono">1</span></div>
          <div class="meta">Moves: <span id="movesOut" class="mono">0</span></div>
          <div class="meta">Invalid: <span id="badOut" class="mono">0</span></div>
          <div class="meta">Resets: <span id="resetOut" class="mono">0</span></div>
          <div class="meta">Cfg: <span id="cfgOut" class="mono">â€”</span></div>
          <div class="meta small">Tap bottle â†’ tap target.</div>
        </div>
      </div>

      <div id="legend" class="legend"></div>
      <div class="grid" id="grid"></div>

      <div class="controls">
        <button id="btnNext">Next Level</button>
        <button id="btnReset">Reset Run</button>
        <span class="small">Filler levels are deterministic. DM visits are seeded + persisted per run.</span>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="pourFX" id="pourFX"></div>

<script type="module">
  import { ELEMENTS, THESES, pickLoreLine } from "./element_schema.js";

  // ---------------- Progression gates ----------------
  const FORESHADOW_START_LEVEL = 10;
  const STABILIZER_UNLOCK_LEVEL = 15;

  const DEFAULT_PROD = "https://ma-bottle-fill-api.onrender.com";
  const DEFAULT_LOCAL = "http://localhost:8787";
  const isLocal = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  const apiBaseEl = document.getElementById("apiBase");
  apiBaseEl.value = isLocal ? DEFAULT_LOCAL : DEFAULT_PROD;

  // ---------- Utilities ----------
  const inflight = new Map();
  function singleFlight(key, fn) {
    if (inflight.has(key)) return inflight.get(key);
    const p = (async () => { try { return await fn(); } finally { inflight.delete(key); } })();
    inflight.set(key, p);
    return p;
  }

  async function postJSON(path, body) {
    const base = apiBaseEl.value.trim().replace(/\/+$/, "");
    const url = base + path;
    const r = await fetch(url, { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body) });
    if (!r.ok) {
      let detailText = "";
      try { detailText = await r.text(); } catch {}
      const retryAfter = r.headers.get("Retry-After");
      const err = new Error(`${r.status} ${r.statusText}${retryAfter ? ` (Retry-After: ${retryAfter}s)` : ""}`);
      err.status = r.status;
      err.retryAfter = retryAfter ? Number(retryAfter) : null;
      err.detailText = detailText;
      throw err;
    }
    return await r.json();
  }

  const toast = document.getElementById("toast");
  function showToast(msg) {
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(()=>toast.classList.remove("show"), 1400);
  }

  function mulberry32(a) {
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }
  function hashSeed(a,b,c){
    let x = (a|0) ^ ((b|0)*0x9E3779B1) ^ ((c|0)*0x85EBCA77);
    x = Math.imul(x ^ (x>>>16), 0x7feb352d);
    x = Math.imul(x ^ (x>>>15), 0x846ca68b);
    x = x ^ (x>>>16);
    return x >>> 0;
  }
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));
  function randInt(min, max, seed) {
    const r = mulberry32(seed)();
    return Math.floor(r * (max - min + 1)) + min;
  }

  function makeRng(seed){
    const f = mulberry32(seed >>> 0);
    return {
      f,
      int(min,max){ return Math.floor(f() * (max - min + 1)) + min; },
      pick(arr){ return arr[Math.floor(f() * arr.length)]; }
    };
  }

  // ---------- DOM ----------
  const statusOut = document.getElementById("statusOut");
  const questTitle = document.getElementById("questTitle");
  const dmIntro = document.getElementById("dmIntro");
  const dmStatus = document.getElementById("dmStatus");
  const dmMid = document.getElementById("dmMid");
  const dmVerdict = document.getElementById("dmVerdict");
  const bankOut = document.getElementById("bankOut");
  const sinsOut = document.getElementById("sinsOut");
  const modOut = document.getElementById("modOut");
  const cfgOut = document.getElementById("cfgOut");
  const recipeSrcOut = document.getElementById("recipeSrcOut");
  const dmCountOut = document.getElementById("dmCountOut");
  const nextDmOut = document.getElementById("nextDmOut");

  const btnQuest = document.getElementById("btnQuest");
  const btnNext = document.getElementById("btnNext");
  const btnReset = document.getElementById("btnReset");

  const grid = document.getElementById("grid");
  const legendEl = document.getElementById("legend");

  const levelOut = document.getElementById("levelOut");
  const movesOut = document.getElementById("movesOut");
  const badOut = document.getElementById("badOut");
  const resetOut = document.getElementById("resetOut");
  const pourFX = document.getElementById("pourFX");

  // ---------- Game / Run State ----------
  let currentElements = [];
  let currentPalette = [];

  let level = 1;
  let questId = 1;

  const sig = { moves:0, invalid:0, resets:0, moveTimes:[], lastMoveAt:0 };
  const avg = (arr)=> arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;

  function inferBANK() {
    const pace = avg(sig.moveTimes.slice(-12));
    const invalidRate = sig.moves ? (sig.invalid / sig.moves) : 0;
    const resetRate = sig.resets ? (sig.resets / Math.max(1, level)) : 0;

    const score = { B:0, A:0, N:0, K:0 };
    score.B += pace > 1400 ? 1.2 : 0;
    score.B += invalidRate < 0.10 ? 1.0 : 0;

    score.A += pace && pace < 900 ? 1.2 : 0;
    score.A += invalidRate < 0.22 ? 0.5 : 0;

    score.N += resetRate > 0.30 ? 1.0 : 0;
    score.N += invalidRate > 0.18 ? 0.6 : 0;

    score.K += invalidRate > 0.12 ? 0.7 : 0;
    score.K += resetRate < 0.25 ? 0.7 : 0;

    const entries = Object.entries(score).sort((a,b)=>b[1]-a[1]);
    const [bankPrimary, top] = entries[0];
    const second = entries[1][1];
    const conf = Math.max(0.25, Math.min(0.92, 0.35 + (top-second)*0.55));
    return { bankPrimary, bankConfidence: Number(conf.toFixed(2)) };
  }

  function inferSinTags() {
    const tags = [];
    if (sig.resets >= 2 && sig.resets > level/2) tags.push("over_reset");
    const pace = avg(sig.moveTimes.slice(-12));
    if (pace > 1500) tags.push("hesitation");
    if ((sig.moves && sig.invalid/sig.moves > 0.18)) tags.push("indecision");
    if (!tags.length) tags.push("steady_hand");
    return tags.slice(0,3);
  }

  // ---------- Thesis selection + palette ----------
  function pickThesisKey(rng, sinTags=[], bankPrimary="K"){
    const tags = new Set(sinTags || []);
    if (tags.has("hesitation")) return "UR_without_CL";
    if (tags.has("indecision")) return "Traffic_without_ME";
    if (tags.has("over_reset")) return "PA_without_PR";

    if (bankPrimary === "A") return "UR_without_CL";
    if (bankPrimary === "K") return "Traffic_without_ME";
    if (bankPrimary === "N") return "PA_without_PR";
    if (bankPrimary === "B") return "VI_without_ST";

    const keys = Object.keys(THESES);
    return rng.pick(keys);
  }

  function chooseElementsForThesis(thesisKey, colorsWanted, rng){
    const thesis = THESES[thesisKey] || null;
    const all = Object.keys(ELEMENTS);

    const mustInclude = thesis?.must_include || [];
    const mustExclude = new Set(thesis?.must_exclude || []);

    const chosen = [];
    for (const sym of mustInclude) {
      if (ELEMENTS[sym] && !chosen.includes(sym)) chosen.push(sym);
    }

    const pool = all.filter(sym => ELEMENTS[sym] && !mustExclude.has(sym) && !chosen.includes(sym));
    while (chosen.length < colorsWanted && pool.length) {
      const idx = Math.floor(rng.f() * pool.length);
      chosen.push(pool.splice(idx,1)[0]);
    }

    while (chosen.length < colorsWanted) {
      chosen.push(all[chosen.length % all.length]);
    }

    return chosen.slice(0, colorsWanted);
  }

  function applyElementPalette(recipe){
    const elems = (recipe.elements || []).slice(0, recipe.colors);
    currentElements = elems;
    currentPalette = elems.map(sym => (ELEMENTS[sym]?.color || "#ffffff"));
  }

  function renderLegend(recipe){
    legendEl.innerHTML = "";

    const thesisKey = recipe.thesisKey;
    const thesis = thesisKey ? THESES[thesisKey] : null;
    if (thesis) {
      const pill = document.createElement("div");
      pill.className = "legendItem thesisPill";
      pill.innerHTML = `
        <div class="legendText">
          <div class="legendTop">Thesis: ${thesis.name}</div>
          <div class="legendSub">Must include: ${(thesis.must_include||[]).join(", ") || "â€”"} Â· Must exclude: ${(thesis.must_exclude||[]).join(", ") || "â€”"}</div>
        </div>
      `;
      legendEl.appendChild(pill);
    }

    for (let i=0; i<currentElements.length; i++){
      const sym = currentElements[i];
      const el = ELEMENTS[sym];
      if (!el) continue;

      const item = document.createElement("div");
      item.className = "legendItem";
      const teaches = el.teaches ? `teaches: ${el.teaches}` : "";
      const punishes = el.punishes ? `punishes: ${el.punishes}` : "";
      item.innerHTML = `
        <div class="swatch" style="background:${el.color}"></div>
        <div class="legendText">
          <div class="legendTop">${el.symbol} â€” ${el.name}</div>
          <div class="legendSub">${[teaches, punishes].filter(Boolean).join(" Â· ")}</div>
        </div>
      `;
      legendEl.appendChild(item);
    }
  }

  // ---------- Modifier (existing UI) ----------
  let pendingModifier = null;
  function formatMod(mod) {
    if (!mod) return "â€”";
    const parts = [];
    const map = [
      ["bottleCountDelta","bottles"],
      ["colorsDelta","colors"],
      ["capacityDelta","cap"],
      ["emptyBottlesDelta","empty"],
      ["lockedBottlesDelta","locks"],
      ["wildcardSlotsDelta","wild"],
    ];
    for (const [k,label] of map) {
      const v = mod[k] ?? 0;
      if (v) parts.push(`${label}${v>0?"+":""}${v}`);
    }
    const tag = mod.ruleTag && mod.ruleTag !== "none" ? mod.ruleTag : "";
    return (parts.length ? parts.join(" ") : "no-delta") + (tag ? ` | ${tag}` : "");
  }
  function setPendingModifier(mod) {
    pendingModifier = mod;
    modOut.textContent = formatMod(mod);
  }

  // ---------- DM Scheduling ----------
  const DM_GAP_MIN = 3;
  const DM_GAP_MAX = 6;
  const DM_MAJOR_EVERY = 5;

  function loadOrInitRunState() {
    let runSeed = Number(localStorage.getItem("ma_runSeed") || "0");
    if (!runSeed) {
      runSeed = Math.floor(Math.random() * 1e9);
      localStorage.setItem("ma_runSeed", String(runSeed));
    }

    let dmAppearCount = Number(localStorage.getItem("ma_dmAppearCount") || "0");
    let nextDMAtLevel = Number(localStorage.getItem("ma_nextDMAtLevel") || "0");

    if (!nextDMAtLevel) {
      nextDMAtLevel = 1 + randInt(DM_GAP_MIN, DM_GAP_MAX, hashSeed(runSeed, 111, 222));
      localStorage.setItem("ma_nextDMAtLevel", String(nextDMAtLevel));
    }

    return { runSeed, dmAppearCount, nextDMAtLevel };
  }

  let { runSeed, dmAppearCount, nextDMAtLevel } = loadOrInitRunState();

  function isDMLevel(lvl) { return lvl === nextDMAtLevel; }
  function isMajorDM(upcomingCount) { return (upcomingCount % DM_MAJOR_EVERY) === 0; }

  function scheduleNextDM(currentLevel) {
    const gap = randInt(DM_GAP_MIN, DM_GAP_MAX, hashSeed(runSeed, dmAppearCount * 97, currentLevel * 131));
    nextDMAtLevel = currentLevel + gap;
    localStorage.setItem("ma_nextDMAtLevel", String(nextDMAtLevel));
  }

  function updateDMButton() {
    dmCountOut.textContent = String(dmAppearCount);
    nextDmOut.textContent = `L${nextDMAtLevel}`;

    if (isDMLevel(level)) {
      const upcoming = dmAppearCount + 1;
      const major = isMajorDM(upcoming);
      btnQuest.disabled = false;
      btnQuest.textContent = major ? "Major Ritual (Brew Modifier)" : "DM Speaks (No Modifier)";

      dmStatus.textContent = major
        ? "A major ritual is available now. Brew a modifier that affects the NEXT level."
        : "Minor DM visit. Story + directive only. No modifier brewed this time.";
    } else {
      btnQuest.disabled = true;
      btnQuest.textContent = `DM @ L${nextDMAtLevel}`;
      dmStatus.textContent =
        `DM appears randomly every ${DM_GAP_MIN}â€“${DM_GAP_MAX} levels. ` +
        `Next appearance: level ${nextDMAtLevel}. ` +
        `Modifiers only brew on every ${DM_MAJOR_EVERY}th DM appearance.`;
    }
  }

  function renderDM(payload) {
    questTitle.textContent = payload.quest_title || "â€”";
    dmIntro.textContent = payload.dm_intro || "";
    dmMid.textContent = payload.dm_midpoint || "";
    dmVerdict.textContent = payload.dm_verdict || "";
  }

  // ---------- DM Click (adds foreshadowOnly) ----------
  btnQuest.addEventListener("click", async () => {
    if (!isDMLevel(level)) return;

    const { bankPrimary, bankConfidence } = inferBANK();
    const sinTags = inferSinTags();

    bankOut.textContent = `${bankPrimary} (${Math.round(bankConfidence*100)}%)`;
    sinsOut.textContent = sinTags.length ? sinTags.join(", ") : "â€”";

    const upcoming = dmAppearCount + 1;
    const wantModifier = isMajorDM(upcoming);

    const foreshadowOnly =
      level >= FORESHADOW_START_LEVEL &&
      level < STABILIZER_UNLOCK_LEVEL;

    statusOut.textContent = wantModifier ? "brewing..." : "speaking...";

    const payload = {
      act: Math.ceil(level/5),
      questId,
      bankPrimary,
      bankConfidence,
      sinTags,
      seed: runSeed,
      level,
      wantModifier,
      foreshadowOnly
    };

    try {
      const key = `quest-node:${runSeed}:${questId}:${level}:${upcoming}:${wantModifier}:${foreshadowOnly}`;
      const data = await singleFlight(key, () => postJSON("/api/quest-node", payload));
      const q = data.payload;

      renderDM(q);

      if (wantModifier) {
        setPendingModifier(q.modifier);
        showToast("Modifier brewed for next level");
      } else {
        setPendingModifier(null);
        showToast("DM visit (no modifier)");
      }

      dmAppearCount = upcoming;
      localStorage.setItem("ma_dmAppearCount", String(dmAppearCount));
      scheduleNextDM(level);
      updateDMButton();

      statusOut.textContent = "ok";
    } catch (e) {
      if (e.status === 429) {
        statusOut.textContent = "rate-limited";
        showToast("Rate limited. Try again soon.");
      } else {
        statusOut.textContent = "dm error";
        showToast("DM error (check server).");
      }
      console.warn(e, e.detailText);
    }
  });

  // ---------- Bottle Game + Stabilizer ----------
  const state = {
    bottles:[],
    capacity:4,
    selected:-1,
    locked:[],
    hiddenSegs:[],
    stabilizer: null // { idx, unlock, symbol, unlocked:false }
  };

  function isSolved() {
    return state.bottles.every(b => {
      if (b.length === 0) return true;
      if (b.length !== state.capacity) return false;
      return b.every(x => x === b[0]);
    });
  }
  const topColor = (b)=> b.length ? b[b.length-1] : null;
  function topRunCount(b){
    if (!b.length) return 0;
    const c = topColor(b);
    let n=0; for(let i=b.length-1;i>=0;i--){ if (b[i]===c) n++; else break; }
    return n;
  }
  function canPour(from,to){
    if (from===to) return false;
    if (state.locked[from] || state.locked[to]) return false;
    const a=state.bottles[from], b=state.bottles[to];
    if (!a.length) return false;
    if (b.length>=state.capacity) return false;
    const color=topColor(a), target=topColor(b);
    return (target===null || target===color);
  }

  function bottleCenter(i){
    const el=document.querySelector(`[data-bottle="${i}"]`);
    if(!el) return {x:innerWidth/2,y:innerHeight/2};
    const r=el.getBoundingClientRect();
    return {x:r.left+r.width/2, y:r.top+r.height/4};
  }
  function playPourFX(from,to,color,amount){
    const a=bottleCenter(from), b=bottleCenter(to);
    pourFX.style.background=color;
    pourFX.style.opacity="1";
    pourFX.style.left=a.x+"px"; pourFX.style.top=a.y+"px";
    const dx=b.x-a.x, dy=b.y-a.y;
    const dur=Math.max(260, Math.min(580, 220+amount*90));
    pourFX.animate([
      { transform:"translate(-50%,-50%) scale(1)", opacity:0.9 },
      { transform:`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.9)`, opacity:0.85 },
      { transform:`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.7)`, opacity:0.0 }
    ], { duration:dur, easing:"cubic-bezier(.2,.8,.2,1)" });
    setTimeout(()=> pourFX.style.opacity="0", dur);
  }

  function checkStabilizerUnlock(){
    if (!state.stabilizer || state.stabilizer.unlocked) return;
    if (state.stabilizer.unlock !== "UR_full") return;

    const urIndex = currentElements.indexOf("UR");
    if (urIndex < 0) return;

    const cap = state.capacity;
    const hasFullUR = state.bottles.some(b =>
      b.length === cap && b.every(x => x === urIndex)
    );

    if (hasFullUR) {
      const idx = state.stabilizer.idx;
      state.locked[idx] = false;
      state.hiddenSegs[idx] = false;
      state.stabilizer.unlocked = true;

      showToast("Clarity unlocked. Now stop panicking.");
      render();
    }
  }

  function doPour(from,to){
    if(!canPour(from,to)){
      sig.invalid++; badOut.textContent=String(sig.invalid);
      showToast("Invalid pour");
      return false;
    }
    const a=state.bottles[from], b=state.bottles[to];
    const color=topColor(a);
    const run=topRunCount(a);
    const space=state.capacity-b.length;
    const amount=Math.min(run,space);

    const now=performance.now();
    if(sig.lastMoveAt) sig.moveTimes.push(now-sig.lastMoveAt);
    sig.lastMoveAt=now;

    playPourFX(from,to,currentPalette[color] || "#ffffff", amount);
    for(let i=0;i<amount;i++) b.push(a.pop());

    sig.moves++; movesOut.textContent=String(sig.moves);
    render();
    checkStabilizerUnlock();

    if(isSolved()){
      const rng = makeRng(hashSeed(runSeed, level, 777));
      showToast(pickLoreLine("win", rng));
      setTimeout(()=>nextLevel(), 650);
    }
    return true;
  }

  const countEmpty = ()=> state.bottles.filter(b=>b.length===0).length;

  function shuffle(arr, rnd=Math.random){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(rnd()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  // ---------- Local filler recipe (schema-driven + gated stabilizer trap) ----------
  let anchorRecipe = null;
  function makeFillerRecipe() {
    const { bankPrimary } = inferBANK();
    const sinTags = inferSinTags();
    const seed = hashSeed(runSeed, level, questId);
    const rnd = mulberry32(seed);
    const rng = makeRng(seed);

    const targetDifficulty = clamp(1 + Math.floor(level / 3) + Math.floor(rnd()*2), 1, 10);

    const base = anchorRecipe ? structuredClone(anchorRecipe) : {
      version: "local-filler",
      title: "Filler Brew",
      lore: "A controlled run. No theatrics. Just results.",
      difficulty: targetDifficulty,
      colors: 5,
      bottleCount: 10,
      capacity: 4,
      emptyBottles: 2,
      lockedBottles: 0,
      wildcardSlots: 0,
      elements: ["CL","PA","PR","AU","TR"],
      thesisKey: "Traffic_without_ME",
      stabilizer: null,
      sinTags: [],
      bonuses: [],
      constraints: [],
      appliedModifier: {
        lockedBottlesDelta:0, emptyBottlesDelta:0, capacityDelta:0,
        wildcardSlotsDelta:0, colorsDelta:0, bottleCountDelta:0,
        ruleTag:"none", bonusObjective:""
      }
    };

    const wobble = (v, min, max, step=1) => clamp(v + (rnd()<0.33?-step:(rnd()>0.66?step:0)), min, max);
    base.version = "local-filler";
    base.difficulty = targetDifficulty;
    base.colors = wobble(clamp(4 + Math.floor(level/4), 4, 10), 4, 10, 1);
    base.capacity = wobble(4 + (level>=18?1:0) + (level>=32?1:0), 3, 6, 1);
    base.emptyBottles = clamp(2 + (rnd()<0.2?1:0) - (rnd()>0.9?1:0), 1, 6);
    base.bottleCount = clamp(base.colors + base.emptyBottles + 3 + Math.floor(rnd()*2), 6, 14);

    base.lockedBottles = clamp((level>=20?1:0) + (rnd()<0.08?1:0), 0, 3);
    base.wildcardSlots = clamp((level>=25 && rnd()<0.15)?1:0, 0, 2);

    base.sinTags = sinTags;
    base.title = `Filler: ${bankPrimary} Distillation`;

    base.thesisKey = pickThesisKey(rng, sinTags, bankPrimary);
    base.elements = chooseElementsForThesis(base.thesisKey, base.colors, rng);

    // ---- Illegal reaction trap (UR_without_CL), gated to later levels ----
    base.stabilizer = null;
    if (base.thesisKey === "UR_without_CL" && level >= STABILIZER_UNLOCK_LEVEL) {
      if (!base.elements.includes("UR")) base.elements[0] = "UR";

      if (!base.elements.includes("CL")) {
        base.elements.push("CL");
        base.colors += 1;
      }

      base.bottleCount = clamp(base.bottleCount + 1, 6, 14);

      base.stabilizer = {
        enabled: true,
        symbol: "CL",
        fill: 2,
        unlock: "UR_full"
      };
    }

    base.lore = `${pickLoreLine("intro", rng)} Thesis: ${THESES[base.thesisKey]?.name || "Unknown Reaction"}.`;
    return base;
  }

  function buildBoardFromRecipe(recipe){
    applyElementPalette(recipe);
    renderLegend(recipe);

    const colors=recipe.colors, bottles=recipe.bottleCount, cap=recipe.capacity, empty=recipe.emptyBottles;
    const rnd = mulberry32(hashSeed(runSeed, level, 1337));

    state.locked = Array(bottles).fill(false);
    state.hiddenSegs = Array(bottles).fill(false);
    state.stabilizer = null;

    const board=Array.from({length:bottles}, ()=>[]);

    const stabilizerEnabled = !!(recipe.stabilizer && recipe.stabilizer.enabled);
    const stabilizerSymbol = stabilizerEnabled ? recipe.stabilizer.symbol : null;
    const stabilizerColorIndex = stabilizerEnabled ? currentElements.indexOf(stabilizerSymbol) : -1;

    const colorStacks=[];
    for(let c=0;c<colors;c++){
      if (stabilizerEnabled && c === stabilizerColorIndex) continue;
      colorStacks.push(Array.from({length:cap}, ()=>c));
    }
    const pool=shuffle(colorStacks.flat(), rnd);

    const fillCount=bottles-empty;
    let idx=0;
    for(let b=0;b<fillCount;b++){
      for(let s=0;s<cap;s++){
        if(idx<pool.length) board[b].push(pool[idx++]);
      }
    }

    if (stabilizerEnabled && stabilizerColorIndex >= 0) {
      const stabIdx = bottles - 1;
      const fill = clamp(recipe.stabilizer.fill ?? 2, 1, cap-1);
      board[stabIdx] = Array.from({length: fill}, ()=> stabilizerColorIndex);

      state.locked[stabIdx] = true;
      state.hiddenSegs[stabIdx] = true;
      state.stabilizer = { idx: stabIdx, unlock: recipe.stabilizer.unlock, symbol: stabilizerSymbol, unlocked:false };
    }

    state.capacity=cap;
    state.bottles=board;
    state.selected=-1;

    const scramble = Math.max(40, Math.min(260, recipe.difficulty*24 + 60));
    for(let k=0;k<scramble;k++){
      const a=Math.floor(rnd()*bottles);
      const t=Math.floor(rnd()*bottles);
      if(a===t) continue;
      if(!canPour(a,t)) continue;
      const from=state.bottles[a], to=state.bottles[t];
      if(!from.length || to.length>=cap) continue;
      const col=topColor(from), tgt=topColor(to);
      if(tgt!==null && tgt!==col) continue;
      to.push(from.pop());
    }
  }

  function nextLevel(){
    level += 1;
    const recipe = makeFillerRecipe();
    buildBoardFromRecipe(recipe);
    recipeSrcOut.textContent = recipe.version || "local";
    render();
  }

  function resetRun(){
    localStorage.removeItem("ma_runSeed");
    localStorage.removeItem("ma_dmAppearCount");
    localStorage.removeItem("ma_nextDMAtLevel");
    location.reload();
  }

  function render(){
    grid.innerHTML="";
    state.bottles.forEach((b,i)=>{
      const bottle=document.createElement("div");

      const locked = !!state.locked[i];
      const hidden = !!state.hiddenSegs[i];

      bottle.className =
        "bottle" +
        (state.selected===i ? " selected" : "") +
        (locked ? " locked" : "") +
        (hidden ? " hiddenSegs" : "");

      bottle.dataset.bottle=String(i);

      for(let s=0;s<state.capacity;s++){
        const seg=document.createElement("div");
        seg.className="seg";

        const ci = b[s] ?? null;
        if (ci === null) {
          seg.style.background = "transparent";
        } else {
          seg.style.background = (currentPalette[ci] || "#ffffff");

          // Pattern overlay classes (role + element symbol)
          const sym = currentElements[ci];
          const role = (ELEMENTS[sym]?.role || "").toLowerCase();
          if (role) seg.classList.add(`role-${role}`);
          if (sym) seg.classList.add(`el-${sym}`);
        }

        bottle.appendChild(seg);
      }

      bottle.addEventListener("click", ()=>{
        if (state.locked[i]) {
          showToast("Stabilizer is sealed. Earn it.");
          return;
        }
        if(state.selected===-1){ state.selected=i; render(); return; }
        if(state.selected===i){ state.selected=-1; render(); return; }
        const success=doPour(state.selected,i);
        state.selected=-1;
        if(!success) render();
      });

      grid.appendChild(bottle);
    });

    levelOut.textContent=String(level);
    movesOut.textContent=String(sig.moves);
    badOut.textContent=String(sig.invalid);
    resetOut.textContent=String(sig.resets);
    cfgOut.textContent=`b${state.bottles.length}/c${state.capacity}/e${countEmpty()}`;
    updateDMButton();
  }

  btnNext.addEventListener("click", nextLevel);
  btnReset.addEventListener("click", ()=>{
    sig.resets++; resetOut.textContent=String(sig.resets);
    showToast("Run reset");
    resetRun();
  });

  // Boot
  dmIntro.textContent = "";
  updateDMButton();
  nextLevel();
</script>
</body>
</html>
