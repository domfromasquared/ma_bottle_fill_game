<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>The Marketing Alchemist â€” Bottle Fill (Mobile)</title>

  <style>
    :root{
      --bg:#060b14;
      --panel:#0c1524;
      --stroke:#1b2b46;
      --txt:#e8eef7;
      --muted:#a9b6c8;

      --pad: 14px;
      --r: 18px;

      /* scaled by JS from #app width */
      --cell: 70px;
      --bottleW: 58px;
      --bottleH: 155px;
      --neckH: 16px;

      /* bottle geometry */
      --glass: rgba(255,255,255,.08);
      --glassEdge: rgba(255,255,255,.18);
      --shine: rgba(255,255,255,.10);

      /* motion */
      --ease: cubic-bezier(.2,.9,.2,1);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height:100%; margin:0; background:#000; color: var(--txt);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { overscroll-behavior:none; touch-action: manipulation; }

    #phone{
      height: 100%;
      display:flex;
      justify-content:center;
      padding:
        calc(env(safe-area-inset-top) + 10px)
        calc(env(safe-area-inset-right) + 10px)
        calc(env(safe-area-inset-bottom) + 10px)
        calc(env(safe-area-inset-left) + 10px);
      background: radial-gradient(1000px 800px at 30% 10%, #0b1a33 0%, #050910 55%, #000 100%);
    }

    #app{
      width: min(440px, 100%);
      height: 100%;
      display:flex;
      flex-direction:column;
      gap: 12px;
      position:relative;
    }

    /* Top: Quest / DM */
    header.top{
      background: linear-gradient(180deg, rgba(12,21,36,0.95), rgba(8,14,25,0.95));
      border:1px solid var(--stroke);
      border-radius: var(--r);
      padding: var(--pad);
    }

    .titleRow{
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
    }
    .brand{
      font-weight: 900; letter-spacing: .2px;
      font-size: 20px; line-height: 1.1;
      display:flex; align-items:center; gap: 8px;
    }

    .rightControls{
      display:flex; align-items:center; gap: 10px;
    }

    .apiPill{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--stroke);
      background: rgba(10,18,32,0.9);
      color: var(--txt);
      padding: 8px 10px;
      border-radius: 999px;
      font-weight: 800;
      max-width: 240px;
    }
    .apiPill .lbl{ opacity:.8; font-weight: 800; }
    .apiPill input{
      width: 150px; max-width: 38vw;
      background: transparent; border:0; outline: none;
      color: var(--txt);
      font-weight: 800;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
    }

    button.pill{
      border:1px solid var(--stroke);
      background: rgba(10,18,32,0.9);
      color: var(--txt);
      padding: 10px 12px;
      border-radius: 999px;
      font-weight: 900;
    }
    button.pill:active{ transform: translateY(1px); }

    .questCard{
      margin-top: 10px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(27,43,70,.9);
      background: rgba(6,11,20,.7);
    }
    .questTitle{
      font-size: 18px;
      font-weight: 900;
      margin-bottom: 6px;
    }
    .questText{
      font-size: 15px;
      color: var(--muted);
      line-height: 1.35;
      min-height: 42px;
    }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 10px;
    }
    .chip{
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(10,18,32,0.9);
      color: var(--txt);
      white-space: nowrap;
    }

    /* Middle: play area */
    main.play{
      flex: 1;
      min-height: 0;
      background: rgba(12,21,36,0.7);
      border:1px solid var(--stroke);
      border-radius: var(--r);
      padding: 12px;
      overflow:hidden;
      position: relative;
    }

    .hudRow{
      display:flex; gap: 8px; align-items:center; justify-content:space-between;
      margin-bottom: 10px;
    }
    .hudLeft, .hudRight{ display:flex; gap: 8px; align-items:center; flex-wrap:wrap; }
    .hudTitle{ font-weight: 900; font-size: 18px; }
    .hudPill{
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(10,18,32,0.9);
      color: var(--txt);
      white-space: nowrap;
    }

    .bottleGrid{
      height: calc(100% - 50px);
      display:grid;
      grid-template-columns: repeat(4, var(--cell));
      justify-content:center;
      align-content:center;
      gap: 10px;
      position: relative;
    }

    /* Bottle */
    .bottleSlot{
      width: var(--cell);
      height: calc(var(--bottleH) + 18px);
      display:flex;
      align-items:flex-end;
      justify-content:center;
      position: relative;
    }

    .bottle{
      width: var(--bottleW);
      height: var(--bottleH);
      border-radius: 14px 14px 16px 16px;
      position: relative;
      border: 2px solid var(--glassEdge);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: 0 10px 20px rgba(0,0,0,.35);
      overflow:hidden;
      transform: translateZ(0);
    }

    .bottle::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(90deg, transparent 0%, var(--shine) 35%, transparent 70%);
      opacity:.5;
      pointer-events:none;
      transform: translateX(-20%);
    }

    .neck{
      position:absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      width: calc(var(--bottleW) * .58);
      height: calc(var(--neckH) + 8px);
      border-radius: 10px 10px 10px 10px;
      border: 2px solid var(--glassEdge);
      background: rgba(255,255,255,.03);
    }

    .liquidStack{
      position:absolute;
      inset: 0;
      display:flex;
      flex-direction:column-reverse;
    }

    .layer{
      width:100%;
      height: 0px;
      transition: height 260ms var(--ease);
    }

    .bottle.selected{
      outline: 3px solid rgba(110,190,255,.95);
      box-shadow: 0 0 0 6px rgba(110,190,255,.15), 0 12px 24px rgba(0,0,0,.5);
    }
    .bottle.invalid{
      animation: shake 240ms var(--ease);
      outline: 3px solid rgba(255,90,90,.95);
      box-shadow: 0 0 0 6px rgba(255,90,90,.15);
    }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-4px); }
      50%{ transform: translateX(4px); }
      75%{ transform: translateX(-3px); }
      100%{ transform: translateX(0); }
    }

    /* Pour animation */
    .pourStream{
      position:absolute;
      width: 10px;
      border-radius: 999px;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.35));
      opacity: 0;
      transform-origin: top center;
    }
    .pourStream.on{
      opacity: 1;
      animation: stream 520ms var(--ease) forwards;
    }
    @keyframes stream{
      0%{ transform: scaleY(.2); }
      25%{ transform: scaleY(1); }
      70%{ transform: scaleY(1); opacity: 1; }
      100%{ transform: scaleY(.25); opacity: 0; }
    }

    /* Bottom layout */
    footer.bottom{
      display:grid;
      grid-template-columns: 120px 1fr;
      gap: 10px;
      align-items:end;
    }

    .characterZone{
      height: 120px;
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: rgba(12,21,36,0.75);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      color: rgba(255,255,255,.55);
    }

    .speechZone{ display:flex; flex-direction:column; gap: 10px; }
    .speechBubble{
      min-height: 76px;
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: rgba(12,21,36,0.75);
      padding: 12px;
      font-size: 14px;
      color: var(--muted);
      line-height: 1.35;
    }
    .modifiersBar{
      height: 58px;
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: rgba(12,21,36,0.75);
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 0 12px;
      overflow:hidden;
      color: rgba(255,255,255,.55);
      font-weight: 900;
    }

    /* Optional left BANK tab */
    .bankTab{
      position:absolute;
      left: -42px;
      top: 110px;
      width: 130px;
      transform: rotate(-90deg);
      transform-origin: left top;
      background: #000;
      border:1px solid var(--stroke);
      color:#fff;
      padding: 8px 10px;
      border-radius: 12px;
      font-weight: 900;
      letter-spacing:.8px;
      text-align:center;
      opacity:.92;
      pointer-events:none;
    }

    /* Small phones: 3 columns */
    @media (max-width: 360px){
      .bottleGrid{ grid-template-columns: repeat(3, var(--cell)); }
      footer.bottom{ grid-template-columns: 100px 1fr; }
      .apiPill input{ width: 120px; }
    }
  </style>
</head>

<body>
  <div id="phone">
    <div id="app">

      <header class="top">
        <div class="titleRow">
          <div class="brand">ðŸ§ª The Marketing Alchemist <span style="opacity:.65; font-weight:900;">(Quest DM)</span></div>

          <div class="rightControls">
            <div class="apiPill" title="API base URL (Render)">
              <span class="lbl">API:</span>
              <input id="apiBase" value="https://ma-bottle-fill-api.onrender.com" />
            </div>
            <button class="pill" id="questBtn">Quest Node</button>
          </div>
        </div>

        <div class="questCard" id="questCard">
          <div class="questTitle" id="questTitle">Mobile Build</div>
          <div class="questText" id="questText">Tap bottles â†’ tap target. Portrait-only layout. DM appears every 3â€“6 levels (random).</div>
          <div class="chips">
            <span class="chip" id="statusChip">Status: ready</span>
            <span class="chip" id="bankChip">BANK: â€”</span>
            <span class="chip" id="sinChip">SinTags: â€”</span>
            <span class="chip" id="cfgChip">LevelCfg: â€”</span>
          </div>
        </div>
      </header>

      <main class="play">
        <div class="hudRow">
          <div class="hudLeft">
            <div class="hudTitle">Bottle Fill</div>
            <div class="hudPill" id="lvlPill">Level: 1</div>
            <div class="hudPill" id="movesPill">Moves: 0</div>
            <div class="hudPill" id="badPill">Invalid: 0</div>
            <div class="hudPill" id="resetPill">Resets: 0</div>
          </div>
          <div class="hudRight">
            <button class="pill" id="nextBtn">Next Level</button>
            <button class="pill" id="resetBtn">Reset Run</button>
          </div>
        </div>

        <div class="bottleGrid" id="bottleGrid"></div>
      </main>

      <footer class="bottom">
        <div class="characterZone" id="characterZone">CHARACTER</div>
        <div class="speechZone">
          <div class="speechBubble" id="speechBubble">SPEECH BUBBLE</div>
          <div class="modifiersBar" id="modifiersBar">MODIFIERS</div>
        </div>
      </footer>

      <div class="bankTab" id="bankTab">BANK IDENTIFIER</div>

    </div>
  </div>

  <script>
    /***********************
     * MOBILE SCALE (core)
     ***********************/
    function applyMobileScale(){
      const app = document.getElementById("app");
      const w = app.clientWidth;

      // scaled for 3â€“4 columns depending on width
      const cell = Math.max(56, Math.min(86, Math.floor(w * 0.18)));
      const bottleW = Math.floor(cell * 0.86);
      const bottleH = Math.floor(cell * 2.25);

      document.documentElement.style.setProperty("--cell", cell + "px");
      document.documentElement.style.setProperty("--bottleW", bottleW + "px");
      document.documentElement.style.setProperty("--bottleH", bottleH + "px");
    }
    window.addEventListener("resize", applyMobileScale, { passive:true });
    window.addEventListener("orientationchange", applyMobileScale, { passive:true });
    applyMobileScale();

    /***********************
     * COLOR PALETTE (distinct)
     ***********************/
    const PALETTE = [
      { id:"AQUA",   hex:"#18c8ff" },
      { id:"LIME",   hex:"#6cff3a" },
      { id:"VIOLET", hex:"#a855ff" },
      { id:"AMBER",  hex:"#ffb020" },
      { id:"ROSE",   hex:"#ff3ea5" },
      { id:"RED",    hex:"#ff3b3b" },
      { id:"BLUE",   hex:"#2f6bff" },
      { id:"TEAL",   hex:"#12f0c0" },
      { id:"SAND",   hex:"#d6b58c" },
      { id:"SLATE",  hex:"#7b8aa8" }
    ];
    const COLOR = Object.fromEntries(PALETTE.map(x => [x.id, x.hex]));

    /***********************
     * GAME STATE
     ***********************/
    const CAP = 4;               // bottle capacity (segments)
    let level = 1;
    let moves = 0;
    let invalid = 0;
    let resets = 0;

    let bottles = [];            // array of arrays bottom->top colors
    let initialBottles = [];
    let selected = -1;

    // DM cadence: random between 3â€“6 levels
    let nextDMAt = rollDM(level);
    let dmVisits = 0;            // how many times DM has appeared
    // modifier cadence: every 5th DM appearance
    const MOD_EVERY = 5;

    // lightweight player signals (for BANK inference on server)
    const telemetry = {
      startedAt: Date.now(),
      taps: 0,
      pours: 0,
      invalid: 0,
      resets: 0,
      hesitations: 0,
      lastTapAt: 0,
      streakBad: 0,
      avgDecisionMs: 0,
      _decisions: []
    };

    /***********************
     * DOM
     ***********************/
    const elGrid = document.getElementById("bottleGrid");
    const lvlPill = document.getElementById("lvlPill");
    const movesPill = document.getElementById("movesPill");
    const badPill = document.getElementById("badPill");
    const resetPill = document.getElementById("resetPill");

    const questBtn = document.getElementById("questBtn");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");

    const apiBaseInput = document.getElementById("apiBase");
    const questTitle = document.getElementById("questTitle");
    const questText = document.getElementById("questText");
    const statusChip = document.getElementById("statusChip");
    const bankChip = document.getElementById("bankChip");
    const sinChip = document.getElementById("sinChip");
    const cfgChip = document.getElementById("cfgChip");
    const speechBubble = document.getElementById("speechBubble");
    const modifiersBar = document.getElementById("modifiersBar");
    const bankTab = document.getElementById("bankTab");

    /***********************
     * UTIL
     ***********************/
    function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
    function deepCopy(x){ return JSON.parse(JSON.stringify(x)); }

    function rollDM(currentLevel){
      // DM every 3â€“6 levels
      const span = 3 + Math.floor(Math.random()*4); // 3..6
      return currentLevel + span;
    }

    function setStatus(text, ok=true){
      statusChip.textContent = "Status: " + text;
      statusChip.style.borderColor = ok ? "rgba(27,43,70,.9)" : "rgba(255,90,90,.95)";
    }

    function apiBase(){
      let v = (apiBaseInput.value || "").trim();
      if (!v) return "";
      // strip trailing slash
      if (v.endsWith("/")) v = v.slice(0,-1);
      return v;
    }

    async function postJSON(path, body){
      const base = apiBase();
      if (!base) throw new Error("Missing API base");
      const url = base + path;
      const res = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body)
      });
      const txt = await res.text();
      let json = null;
      try{ json = JSON.parse(txt); }catch(_){}
      if (!res.ok){
        const errMsg = (json && json.error) ? json.error : (txt || ("HTTP " + res.status));
        const e = new Error(errMsg);
        e.status = res.status;
        e.details = json && json.details;
        throw e;
      }
      return json;
    }

    /***********************
     * LEVEL GENERATION
     * - Tries server /api/level-recipe
     * - Falls back to deterministic local recipe
     ***********************/
    function localLevelRecipe(level){
      // deterministic-ish: seed by level
      const rng = mulberry32(0xC0FFEE ^ (level * 2654435761));
      const colorsCount = clamp(3 + Math.floor(level/3), 3, 8);
      const bottleCount = clamp(6 + Math.floor(level/2), 6, 10);
      const empties = 2;

      const colors = PALETTE.slice(0, colorsCount).map(c => c.id);
      // create a pool of segments (each color repeats CAP times)
      let pool = [];
      for (const c of colors){
        for (let i=0;i<CAP;i++) pool.push(c);
      }
      // add extra segments if bottleCount*CAP > pool size, repeat colors
      while (pool.length < (bottleCount-empties)*CAP){
        const c = colors[Math.floor(rng()*colors.length)];
        pool.push(c);
      }
      // shuffle pool
      for (let i=pool.length-1;i>0;i--){
        const j = Math.floor(rng()*(i+1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }

      // fill bottles
      const b = [];
      for (let i=0;i<bottleCount-empties;i++){
        b.push(pool.slice(i*CAP, (i+1)*CAP));
      }
      for (let i=0;i<empties;i++) b.push([]);
      return {
        bottleCount,
        capacity: CAP,
        colors,
        bottles: b,
        levelCfg: `b${bottleCount}/c${colorsCount}/cap${CAP}/local`
      };
    }

    function mulberry32(a){
      return function(){
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    async function buildLevel(level){
      setStatus("loading levelâ€¦");
      // try server
      try{
        const payload = {
          level,
          mode: "mobile",
          capacity: CAP,
          telemetry: packTelemetry(),
        };
        const data = await postJSON("/api/level-recipe", payload);
        // expect { ok:true, recipe:{bottles:[...], capacity, levelCfg, ...} }
        const recipe = data.recipe || data.level || data;
        applyRecipe(recipe);
        cfgChip.textContent = "LevelCfg: " + (recipe.levelCfg || "server");
        setStatus("level ready");
        return;
      }catch(e){
        // fallback local
        const recipe = localLevelRecipe(level);
        applyRecipe(recipe);
        cfgChip.textContent = "LevelCfg: " + recipe.levelCfg;
        setStatus("level ready (fallback)", false);
      }
    }

    function applyRecipe(recipe){
      const b = recipe.bottles || [];
      bottles = deepCopy(b);
      initialBottles = deepCopy(b);
      selected = -1;
      moves = 0;
      invalid = 0;
      updateHUD();
      render();
    }

    /***********************
     * POUR RULES
     ***********************/
    function topColor(b){
      if (!b.length) return null;
      return b[b.length - 1];
    }

    function topRunCount(b){
      if (!b.length) return 0;
      const c = topColor(b);
      let n = 0;
      for (let i=b.length-1;i>=0;i--){
        if (b[i] !== c) break;
        n++;
      }
      return n;
    }

    function canPour(fromIdx, toIdx){
      if (fromIdx === toIdx) return false;
      const from = bottles[fromIdx];
      const to = bottles[toIdx];
      if (!from.length) return false;
      if (to.length >= CAP) return false;

      const fc = topColor(from);
      const tc = topColor(to);
      if (!tc) return true;              // empty target
      return tc === fc;                  // must match
    }

    function pourAmount(fromIdx, toIdx){
      const from = bottles[fromIdx];
      const to = bottles[toIdx];
      const run = topRunCount(from);
      const space = CAP - to.length;
      return Math.min(run, space);
    }

    function doPour(fromIdx, toIdx){
      if (!canPour(fromIdx, toIdx)) return false;
      const amt = pourAmount(fromIdx, toIdx);
      if (amt <= 0) return false;

      const c = topColor(bottles[fromIdx]);
      for (let i=0;i<amt;i++){
        bottles[fromIdx].pop();
        bottles[toIdx].push(c);
      }
      return { amt, color: c };
    }

    function isSolved(){
      // solved if every bottle is empty or full and all same color
      for (const b of bottles){
        if (!b.length) continue;
        if (b.length !== CAP) return false;
        const c = b[0];
        for (let i=1;i<b.length;i++){
          if (b[i] !== c) return false;
        }
      }
      return true;
    }

    /***********************
     * RENDER
     ***********************/
    function updateHUD(){
      lvlPill.textContent = "Level: " + level;
      movesPill.textContent = "Moves: " + moves;
      badPill.textContent = "Invalid: " + invalid;
      resetPill.textContent = "Resets: " + resets;
    }

    function render(){
      elGrid.innerHTML = "";

      const cols = (window.innerWidth <= 360) ? 3 : 4;
      // if too many bottles, allow wrapping naturally; grid is centered.

      bottles.forEach((b, idx) => {
        const slot = document.createElement("div");
        slot.className = "bottleSlot";

        const bottle = document.createElement("div");
        bottle.className = "bottle";
        bottle.dataset.idx = String(idx);

        if (idx === selected) bottle.classList.add("selected");

        const neck = document.createElement("div");
        neck.className = "neck";

        const stack = document.createElement("div");
        stack.className = "liquidStack";

        // each segment is equal height
        const segH = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--bottleH")) / CAP);
        for (let i=0;i<CAP;i++){
          const layer = document.createElement("div");
          layer.className = "layer";
          const c = b[i] || null; // bottom->top, but our b is bottom->top already
          if (c){
            layer.style.background = COLOR[c] || c;
            layer.style.height = segH + "px";
          }else{
            layer.style.height = "0px";
          }
          stack.appendChild(layer);
        }

        bottle.appendChild(stack);
        bottle.appendChild(neck);
        slot.appendChild(bottle);
        elGrid.appendChild(slot);

        bottle.addEventListener("click", () => onBottleTap(idx));
      });
    }

    function markInvalid(idx){
      const node = elGrid.querySelector(`.bottle[data-idx="${idx}"]`);
      if (!node) return;
      node.classList.remove("invalid");
      void node.offsetWidth; // reflow
      node.classList.add("invalid");
      setTimeout(() => node.classList.remove("invalid"), 260);
    }

    /***********************
     * POUR ANIMATION (satisfying stream)
     ***********************/
    function streamPour(fromIdx, toIdx, colorHex){
      const fromEl = elGrid.querySelector(`.bottle[data-idx="${fromIdx}"]`);
      const toEl = elGrid.querySelector(`.bottle[data-idx="${toIdx}"]`);
      if (!fromEl || !toEl) return;

      const gridRect = elGrid.getBoundingClientRect();
      const a = fromEl.getBoundingClientRect();
      const b = toEl.getBoundingClientRect();

      const x1 = (a.left + a.right)/2 - gridRect.left;
      const y1 = a.top - gridRect.top + 8;
      const x2 = (b.left + b.right)/2 - gridRect.left;
      const y2 = b.top - gridRect.top + 10;

      const dx = x2 - x1;
      const dy = Math.max(40, y2 - y1);

      const stream = document.createElement("div");
      stream.className = "pourStream";
      stream.style.left = (x1 - 5) + "px";
      stream.style.top = (y1) + "px";
      stream.style.height = dy + "px";
      stream.style.background = colorHex;
      stream.style.transform = `rotate(${Math.atan2(dy, dx) * 180/Math.PI}deg)`;
      stream.style.width = "10px";

      elGrid.appendChild(stream);
      requestAnimationFrame(() => stream.classList.add("on"));
      setTimeout(() => stream.remove(), 620);
    }

    /***********************
     * INPUT (tap source -> tap target)
     ***********************/
    function onBottleTap(idx){
      const now = Date.now();
      telemetry.taps++;
      if (telemetry.lastTapAt){
        const dt = now - telemetry.lastTapAt;
        telemetry._decisions.push(dt);
        telemetry.avgDecisionMs = Math.round(telemetry._decisions.reduce((a,b)=>a+b,0)/telemetry._decisions.length);
      }
      telemetry.lastTapAt = now;

      if (selected === -1){
        // select only if not empty
        if (!bottles[idx].length){
          markInvalid(idx);
          invalid++;
          telemetry.invalid++;
          updateHUD();
          return;
        }
        selected = idx;
        render();
        return;
      }

      // second tap: attempt pour
      const from = selected;
      const to = idx;

      if (from === to){
        // deselect
        selected = -1;
        render();
        return;
      }

      if (!canPour(from, to)){
        invalid++;
        telemetry.invalid++;
        telemetry.streakBad++;
        markInvalid(to);
        // keep selection so user can try another target
        updateHUD();
        return;
      }

      const beforeColor = topColor(bottles[from]);
      const result = doPour(from, to);
      moves++;
      telemetry.pours++;
      telemetry.streakBad = 0;
      updateHUD();

      // animate stream
      streamPour(from, to, COLOR[beforeColor] || beforeColor);

      // re-render after a short delay to let stream read
      setTimeout(() => {
        render();
        // solved?
        if (isSolved()){
          speechBubble.textContent = "Solved. Yes, yes. You can stop panic-pouring now.";
          // auto advance after a beat (optional)
        }
      }, 160);

      // auto-deselect if source is empty
      if (!bottles[from].length) selected = -1;
    }

    /***********************
     * DM / QUEST CADENCE
     * - DM appears at random level intervals (3â€“6)
     * - Modifiers only produced every 5th DM appearance
     ***********************/
    function shouldShowDM(){
      return level >= nextDMAt;
    }

    function shouldRequestModifier(){
      // only every 5th DM appearance
      return (dmVisits > 0) && (dmVisits % MOD_EVERY === 0);
    }

    function packTelemetry(){
      return {
        sessionMs: Date.now() - telemetry.startedAt,
        taps: telemetry.taps,
        pours: telemetry.pours,
        invalid: telemetry.invalid,
        resets: telemetry.resets,
        avgDecisionMs: telemetry.avgDecisionMs,
        streakBad: telemetry.streakBad,
        level,
        moves,
      };
    }

    async function fetchQuestNode({force=false} = {}){
      const dmNow = force || shouldShowDM();
      if (!dmNow){
        questTitle.textContent = "No DM right now";
        questText.textContent = "Keep brewing. DM appears every 3â€“6 levels (random).";
        return;
      }

      dmVisits++;
      // if we just triggered DM due to cadence, schedule next
      if (!force){
        nextDMAt = rollDM(level);
      }

      const wantModifier = shouldRequestModifier();

      setStatus("brewing questâ€¦");
      questTitle.textContent = wantModifier ? "Major Ritual (Modifiers)" : "Minor Check-in";
      questText.textContent = "Summoning the DMâ€¦";

      try{
        const payload = {
          level,
          cadence: { dmEveryMin: 3, dmEveryMax: 6, modifierEveryDM: MOD_EVERY },
          wantModifier,
          telemetry: packTelemetry(),
          // IMPORTANT: prevent BANK confusion with banker/finance
          bankDefinition: "BANK is a marketing personality system (Blueprint/Action/Nurturing/Knowledge). Not related to finance or banking."
        };

        const data = await postJSON("/api/quest-node", payload);
        // expected: { ok:true, node:{ title, text, bank, bank_confidence, sinTags, modifier, levelCfg, ... } }
        const node = data.node || data.quest || data;

        questTitle.textContent = node.quest_title || node.title || (wantModifier ? "Major Ritual" : "Minor DM Check-in");
        questText.textContent = node.quest_text || node.text || "â€¦";

        // UI chips
        const b = node.bank || node.bank_letter || "â€”";
        const conf = (node.bank_confidence != null) ? node.bank_confidence : node.bank_score;
        bankChip.textContent = `BANK: ${b}${(conf!=null) ? ` (${Number(conf).toFixed(2)})` : ""}`;

        const sins = node.sinTags || node.sin_tags || [];
        sinChip.textContent = "SinTags: " + (Array.isArray(sins) ? sins.join(", ") : (sins || "â€”"));

        if (node.levelCfg) cfgChip.textContent = "LevelCfg: " + node.levelCfg;

        // show speech + modifiers
        speechBubble.textContent = node.dm_line || node.quest_dm_line || node.voice_line || node.quest_text || "â€¦";

        const mod = node.modifier || node.modifiers || null;
        if (wantModifier && mod){
          modifiersBar.textContent = "MODIFIERS: " + JSON.stringify(mod);
        } else {
          modifiersBar.textContent = "MODIFIERS";
        }

        // bank tab
        bankTab.textContent = "BANK IDENTIFIER: " + b;

        setStatus("quest ready");
      }catch(e){
        setStatus("quest error", false);
        questTitle.textContent = "Fallback Brew (Server Offline)";
        questText.textContent = "The lab lights flicker. Your API gremlins demand tribute. Brew anyway.";
        speechBubble.textContent = "Tap bottles â†’ tap target. Stop overthinking, apprentice.";
      }
    }

    /***********************
     * BUTTONS
     ***********************/
    questBtn.addEventListener("click", () => fetchQuestNode({force:true}));

    nextBtn.addEventListener("click", async () => {
      level++;
      selected = -1;

      // If cadence hits, fetch DM automatically (minor/major logic)
      if (shouldShowDM()){
        await fetchQuestNode({force:false});
      } else {
        // quiet UI
        questTitle.textContent = "Brew in progress";
        questText.textContent = "No DM. Deterministic level between rituals.";
      }

      await buildLevel(level);
    });

    resetBtn.addEventListener("click", async () => {
      resets++;
      telemetry.resets++;
      selected = -1;
      // restore initial state
      bottles = deepCopy(initialBottles);
      moves = 0;
      invalid = 0;
      updateHUD();
      render();
      setStatus("reset");
      speechBubble.textContent = "Reset again? Beautiful. Indecision in its natural habitat.";
    });

    /***********************
     * INIT
     ***********************/
    (async function init(){
      // initial DM message
      questTitle.textContent = "Mobile Layout Locked";
      questText.textContent = "Portrait-first. No desktop drift. Tap bottle â†’ tap target. DM appears randomly every 3â€“6 levels.";

      // build level 1
      await buildLevel(level);

      // optional: initial DM on first load? (off by default)
      // await fetchQuestNode({force:true});
    })();
  </script>
</body>
</html>
