<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Marketing Alchemist â€” Bottle Fill (Quest DM)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f14; color:#e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; display:flex; flex-direction:column; gap:14px; }
    .card { border:1px solid #243244; border-radius: 18px; background: linear-gradient(180deg,#0f1724,#0b121c); box-shadow: 0 20px 50px rgba(0,0,0,.25); overflow:hidden; }
    .cardHeader { display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid #1e2a3c; }
    .title { font-size: 34px; font-weight: 800; letter-spacing: -0.5px; display:flex; align-items:center; gap:10px;}
    .pill { border:1px solid #243244; border-radius: 999px; padding: 8px 12px; background:#0b121c; display:inline-flex; align-items:center; gap:10px; }
    .pill input { width: 360px; max-width: 56vw; background: transparent; border: none; outline: none; color:#e6edf3; font: inherit; }
    button { cursor:pointer; border:1px solid #243244; background:#111a27; color:#e6edf3; border-radius: 14px; padding: 10px 14px; font-weight: 700; }
    button:disabled { opacity: .55; cursor:not-allowed; }
    .content { padding: 18px 16px; }
    h2 { margin: 0 0 10px 0; font-size: 36px; letter-spacing: -0.5px; }
    p { margin: 0 0 10px 0; font-size: 26px; line-height: 1.22; color:#d7deea; }
    .metaRow { display:flex; flex-wrap:wrap; gap:10px; margin-top:14px; }
    .meta { display:inline-flex; align-items:center; gap:10px; border:1px solid #243244; border-radius: 999px; padding: 10px 12px; background:#0b121c; font-size: 20px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 16px; color:#aab6ca; }
    .split { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .gameHeader { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .stats { display:flex; gap:10px; flex-wrap:wrap; }
    .grid { display:flex; flex-wrap:wrap; gap:16px; padding: 18px 16px; min-height: 300px; }
    .bottle {
      width: 84px; height: 220px;
      border-radius: 22px 22px 26px 26px;
      border: 2px solid rgba(220,232,255,.14);
      background: rgba(0,0,0,.25);
      position:relative;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.03);
      display:flex; flex-direction:column-reverse;
      overflow:hidden;
      user-select:none;
      touch-action: manipulation;
      transform: translateZ(0);
    }
    .bottle::before {
      content:"";
      position:absolute; inset: 10px 10px 10px 10px;
      border-radius: 18px 18px 22px 22px;
      border:1px solid rgba(255,255,255,.06);
      pointer-events:none;
    }
    .bottle.selected { outline: 3px solid rgba(130, 210, 255,.45); box-shadow: 0 0 0 6px rgba(80,140,255,.12), inset 0 0 0 2px rgba(255,255,255,.04); }
    .seg { width:100%; height: 22%; }
    .controls { display:flex; gap:10px; padding: 0 16px 16px 16px; }
    .toast { position: fixed; left: 50%; bottom: 22px; transform: translateX(-50%); background:#0b121c; border:1px solid #243244; border-radius: 999px; padding: 10px 14px; font-weight:700; opacity:0; transition: opacity .18s ease; pointer-events:none;}
    .toast.show { opacity:1; }
    .pourFX {
      position: fixed; width: 10px; height: 10px; border-radius: 999px;
      pointer-events:none;
      opacity:0;
      transform: translate(-50%, -50%);
      filter: blur(.2px);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Quest DM -->
    <div class="card" id="dmCard">
      <div class="cardHeader">
        <div class="title">ðŸ§ª The Marketing Alchemist <span style="opacity:.7">(Quest DM)</span></div>
        <div class="split">
          <div class="pill">
            <span style="opacity:.7">API:</span>
            <input id="apiBase" class="mono" />
          </div>
          <button id="btnQuest">Quest Node</button>
        </div>
      </div>
      <div class="content">
        <h2 id="questTitle">â€”</h2>
        <p id="dmIntro" class="small">Press <b>Quest Node</b> to brew the next scene.</p>
        <p id="dmMid" class="small"></p>
        <p id="dmVerdict" class="small"></p>

        <div class="metaRow">
          <div class="meta">B.A.N.K: <span id="bankOut" class="mono">â€”</span></div>
          <div class="meta">SinTags: <span id="sinsOut" class="mono">â€”</span></div>
          <div class="meta">LevelCfg: <span id="cfgOut" class="mono">â€”</span></div>
          <div class="meta">Status: <span id="statusOut" class="mono">ready</span></div>
        </div>
      </div>
    </div>

    <!-- Game -->
    <div class="card">
      <div class="cardHeader gameHeader">
        <div class="title" style="font-size:28px">Bottle Fill</div>
        <div class="stats">
          <div class="meta">Level: <span id="levelOut" class="mono">1</span></div>
          <div class="meta">Moves: <span id="movesOut" class="mono">0</span></div>
          <div class="meta">Invalid: <span id="badOut" class="mono">0</span></div>
          <div class="meta">Resets: <span id="resetOut" class="mono">0</span></div>
          <div class="meta small">Tap bottle â†’ tap target. Satisfying pour.</div>
        </div>
      </div>
      <div class="grid" id="grid"></div>
      <div class="controls">
        <button id="btnNext">Next Level</button>
        <button id="btnReset">Reset Run</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="pourFX" id="pourFX"></div>

<script type="module">
  // ---------------------------
  // API base auto-detect
  // ---------------------------
  const DEFAULT_PROD = "https://ma-bottle-fill-api.onrender.com";
  const DEFAULT_LOCAL = "http://localhost:8787";
  const isLocal = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  const apiBaseEl = document.getElementById("apiBase");
  apiBaseEl.value = isLocal ? DEFAULT_LOCAL : DEFAULT_PROD;

  // ---------------------------
  // Single-flight + cooldown (CLIENT)
  // ---------------------------
  const inflight = new Map(); // key -> Promise
  function singleFlight(key, fn) {
    if (inflight.has(key)) return inflight.get(key);
    const p = (async () => {
      try { return await fn(); }
      finally { inflight.delete(key); }
    })();
    inflight.set(key, p);
    return p;
  }

  let cooldownUntil = 0;
  function canCallNow() { return Date.now() >= cooldownUntil; }
  function setCooldown(ms=2500) { cooldownUntil = Date.now() + ms; }

  // ---------------------------
  // UI helpers
  // ---------------------------
  const statusOut = document.getElementById("statusOut");
  const questTitle = document.getElementById("questTitle");
  const dmIntro = document.getElementById("dmIntro");
  const dmMid = document.getElementById("dmMid");
  const dmVerdict = document.getElementById("dmVerdict");
  const bankOut = document.getElementById("bankOut");
  const sinsOut = document.getElementById("sinsOut");
  const cfgOut = document.getElementById("cfgOut");

  const toast = document.getElementById("toast");
  function showToast(msg) {
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(()=>toast.classList.remove("show"), 1400);
  }

  // ---------------------------
  // Player/run state
  // ---------------------------
  let runSeed = Math.floor(Math.random() * 1e9);
  let questId = 1;
  let level = 1;

  // Player inference signals (simple starter)
  const sig = {
    moves: 0,
    invalid: 0,
    resets: 0,
    moveTimes: [],
    lastMoveAt: 0,
  };

  function avg(arr) {
    if (!arr.length) return 0;
    return arr.reduce((a,b)=>a+b,0) / arr.length;
  }

  // crude BANK classifier (starter): picks based on speed + resets + invalid
  function inferBANK() {
    const pace = avg(sig.moveTimes.slice(-12)); // ms
    const invalidRate = sig.moves ? (sig.invalid / sig.moves) : 0;
    const resetRate = sig.resets ? (sig.resets / Math.max(1, level)) : 0;

    // heuristic scoring
    const score = { B: 0, A: 0, N: 0, K: 0 };

    // Blueprint: slower, methodical, low invalid
    score.B += pace > 1400 ? 1.2 : 0;
    score.B += invalidRate < 0.10 ? 1.0 : 0;

    // Action: fast, fewer hesitations
    score.A += pace && pace < 900 ? 1.2 : 0;
    score.A += invalidRate < 0.22 ? 0.5 : 0;

    // Nurturing: more resets / hesitation (not badâ€”just style)
    score.N += resetRate > 0.30 ? 1.0 : 0;
    score.N += invalidRate > 0.18 ? 0.6 : 0;

    // Knowledge: experiments, some invalid but low resets
    score.K += invalidRate > 0.12 ? 0.7 : 0;
    score.K += resetRate < 0.25 ? 0.7 : 0;

    const entries = Object.entries(score).sort((a,b)=>b[1]-a[1]);
    const [bankPrimary, top] = entries[0];
    const second = entries[1][1];
    const conf = Math.max(0.25, Math.min(0.92, 0.35 + (top - second) * 0.55));
    return { bankPrimary, bankConfidence: Number(conf.toFixed(2)) };
  }

  function inferSinTags() {
    const tags = [];
    if (sig.resets >= 2 && sig.resets > level/2) tags.push("over_reset");
    const pace = avg(sig.moveTimes.slice(-12));
    if (pace > 1500) tags.push("hesitation");
    if ((sig.moves && sig.invalid/sig.moves > 0.18)) tags.push("indecision");
    if (!tags.length) tags.push("steady_hand");
    return tags.slice(0,3);
  }

  // ---------------------------
  // Fetch helpers (with 429 backoff)
  // ---------------------------
  async function postJSON(path, body) {
    const base = apiBaseEl.value.trim().replace(/\/+$/, "");
    const url = base + path;
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body)
    });

    if (!r.ok) {
      let detailText = "";
      try { detailText = await r.text(); } catch {}
      const retryAfter = r.headers.get("Retry-After");
      const err = new Error(`${r.status} ${r.statusText}${retryAfter ? ` (Retry-After: ${retryAfter}s)` : ""}`);
      err.status = r.status;
      err.retryAfter = retryAfter ? Number(retryAfter) : null;
      err.detailText = detailText;
      throw err;
    }
    return await r.json();
  }

  // ---------------------------
  // Quest Node (CLIENT)
  // ---------------------------
  async function fetchQuestNode() {
    const { bankPrimary, bankConfidence } = inferBANK();
    const sinTags = inferSinTags();

    bankOut.textContent = `${bankPrimary} (${bankConfidence})`;
    sinsOut.textContent = sinTags.join(", ");

    statusOut.textContent = "brewing...";
    const payload = {
      act: Math.ceil(level/5),
      questId,
      bankPrimary,
      bankConfidence,
      sinTags,
      seed: runSeed,
      level
    };

    try {
      const data = await postJSON("/api/quest-node", payload);
      const q = data.payload;
      questTitle.textContent = q.quest_title;
      dmIntro.textContent = q.dm_intro;
      dmMid.textContent = q.dm_midpoint;
      dmVerdict.textContent = q.dm_verdict;
      statusOut.textContent = "ok";
    } catch (e) {
      // 429: respect retry-after by extending cooldown
      if (e.status === 429) {
        const ms = (e.retryAfter ? e.retryAfter * 1000 : 20000);
        setCooldown(ms);
        statusOut.textContent = "rate-limited";
        showToast("Rate limited. Brewing cooldownâ€¦");
      } else {
        statusOut.textContent = "quest error";
        showToast("Quest error (check server).");
      }
      // Keep a readable fallback
      questTitle.textContent = "Fallback Brew (Server Unhappy)";
      dmIntro.textContent = "The lab lights flicker. Your API gremlins demand tribute. Brew anyway.";
      dmMid.textContent = "Stop spam-clicking like a raccoon at a vending machine. One pull. One pour.";
      dmVerdict.textContent = "Run clean experiments. Fewer retries. Better results. [SIG:MA_V1]";
      console.warn(e, e.detailText);
    }
  }

  document.getElementById("btnQuest").addEventListener("click", async () => {
    if (!canCallNow()) return;
    setCooldown(2500);
    await singleFlight("quest-node", fetchQuestNode);
  });

  // ---------------------------
  // Bottle fill game (simple water-sort)
  // ---------------------------
  const grid = document.getElementById("grid");
  const levelOut = document.getElementById("levelOut");
  const movesOut = document.getElementById("movesOut");
  const badOut = document.getElementById("badOut");
  const resetOut = document.getElementById("resetOut");
  const pourFX = document.getElementById("pourFX");

  const PALETTE = [
    "#00D1FF", // cyan
    "#FF4D6D", // hot pink-red
    "#FFD400", // yellow
    "#7CFF6B", // neon green
    "#A855F7", // purple
    "#FF8A00", // orange
    "#00FFA8", // mint
    "#2E5BFF", // royal blue
    "#FF3DF2", // magenta
    "#C2FF00", // lime
  ];

  const state = {
    bottles: [],
    capacity: 4,
    selected: -1
  };

  function isSolved() {
    return state.bottles.every(b => {
      if (b.length === 0) return true;
      if (b.length !== state.capacity) return false;
      return b.every(x => x === b[0]);
    });
  }

  function topColor(b) {
    if (!b.length) return null;
    return b[b.length - 1];
  }
  function topRunCount(b) {
    if (!b.length) return 0;
    const c = topColor(b);
    let n = 0;
    for (let i = b.length - 1; i >= 0; i--) {
      if (b[i] === c) n++;
      else break;
    }
    return n;
  }

  function canPour(from, to) {
    if (from === to) return false;
    const a = state.bottles[from];
    const b = state.bottles[to];
    if (!a.length) return false;
    if (b.length >= state.capacity) return false;

    const color = topColor(a);
    const target = topColor(b);
    return (target === null || target === color);
  }

  function doPour(from, to) {
    if (!canPour(from, to)) {
      sig.invalid++;
      badOut.textContent = String(sig.invalid);
      showToast("Invalid pour");
      return false;
    }
    const a = state.bottles[from];
    const b = state.bottles[to];

    const color = topColor(a);
    const run = topRunCount(a);
    const space = state.capacity - b.length;
    const amount = Math.min(run, space);

    // record timing
    const now = performance.now();
    if (sig.lastMoveAt) sig.moveTimes.push(now - sig.lastMoveAt);
    sig.lastMoveAt = now;

    // animate "stream"
    playPourFX(from, to, color, amount);

    for (let i = 0; i < amount; i++) {
      b.push(a.pop());
    }
    sig.moves++;
    movesOut.textContent = String(sig.moves);
    render();

    if (isSolved()) {
      showToast("Solved! Next levelâ€¦");
      setTimeout(()=>nextLevel(), 700);
    }
    return true;
  }

  function bottleCenter(i) {
    const el = document.querySelector(`[data-bottle="${i}"]`);
    if (!el) return {x: innerWidth/2, y: innerHeight/2};
    const r = el.getBoundingClientRect();
    return { x: r.left + r.width/2, y: r.top + r.height/4 };
  }

  function playPourFX(from, to, color, amount) {
    const a = bottleCenter(from);
    const b = bottleCenter(to);
    pourFX.style.background = color;
    pourFX.style.opacity = "1";
    pourFX.style.left = a.x + "px";
    pourFX.style.top = a.y + "px";

    const dx = b.x - a.x;
    const dy = b.y - a.y;

    const dur = Math.max(260, Math.min(580, 220 + amount * 90));
    pourFX.animate([
      { transform: "translate(-50%,-50%) scale(1)", opacity: 0.9 },
      { transform: `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.9)`, opacity: 0.85 },
      { transform: `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.7)`, opacity: 0.0 }
    ], { duration: dur, easing: "cubic-bezier(.2,.8,.2,1)" });

    setTimeout(()=>{ pourFX.style.opacity="0"; }, dur);
  }

  function render() {
    grid.innerHTML = "";
    state.bottles.forEach((b, i) => {
      const bottle = document.createElement("div");
      bottle.className = "bottle" + (state.selected === i ? " selected" : "");
      bottle.dataset.bottle = String(i);

      // segments bottom-up
      for (let s = 0; s < state.capacity; s++) {
        const seg = document.createElement("div");
        seg.className = "seg";
        const colorIndex = b[s] ?? null;
        seg.style.background = colorIndex === null ? "transparent" : PALETTE[colorIndex % PALETTE.length];
        bottle.appendChild(seg);
      }

      bottle.addEventListener("click", () => {
        if (state.selected === -1) {
          state.selected = i;
          render();
          return;
        }
        if (state.selected === i) {
          state.selected = -1;
          render();
          return;
        }
        // try pour
        const success = doPour(state.selected, i);
        state.selected = -1;
        if (!success) render();
      });

      grid.appendChild(bottle);
    });

    levelOut.textContent = String(level);
    movesOut.textContent = String(sig.moves);
    badOut.textContent = String(sig.invalid);
    resetOut.textContent = String(sig.resets);

    // simple cfg tag for DM
    cfgOut.textContent = `b${state.bottles.length}/c${state.capacity}/e${countEmpty()}`;
  }

  function countEmpty() {
    return state.bottles.filter(b => b.length === 0).length;
  }

  // ---------------------------
  // Level recipe -> generate solvable-ish boards
  // ---------------------------
  function shuffle(arr) {
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  function buildBoardFromRecipe(recipe) {
    const colors = recipe.colors;
    const bottles = recipe.bottleCount;
    const cap = recipe.capacity;
    const empty = recipe.emptyBottles;

    // Build solved stacks for each color
    const colorStacks = [];
    for (let c=0;c<colors;c++){
      colorStacks.push(Array.from({length:cap}, ()=>c));
    }

    // Combine and shuffle into a pool
    const pool = shuffle(colorStacks.flat());

    // create bottles
    const board = Array.from({length:bottles}, ()=>[]);
    // fill bottles except empties
    const fillCount = bottles - empty;
    let idx = 0;
    for (let b=0;b<fillCount;b++){
      for (let s=0;s<cap;s++){
        if (idx < pool.length) board[b].push(pool[idx++]);
      }
    }

    // scramble: perform random valid-ish pours to create a puzzle
    state.capacity = cap;
    state.bottles = board;
    state.selected = -1;

    const scramble = Math.max(40, Math.min(240, recipe.difficulty * 22 + 60));
    for (let k=0;k<scramble;k++){
      const a = Math.floor(Math.random()*bottles);
      const t = Math.floor(Math.random()*bottles);
      if (a===t) continue;
      if (!canPour(a,t)) continue;
      // do a single unit pour in scramble to avoid instantly solved
      const from = state.bottles[a];
      const to = state.bottles[t];
      if (!from.length || to.length>=cap) continue;
      const col = topColor(from);
      const tgt = topColor(to);
      if (tgt !== null && tgt !== col) continue;
      to.push(from.pop());
    }
  }

  async function fetchLevelRecipe() {
    const { bankPrimary, bankConfidence } = inferBANK();
    const sinTags = inferSinTags();

    const payload = {
      act: Math.ceil(level/5),
      questId,
      bankPrimary,
      bankConfidence,
      sinTags,
      seed: runSeed,
      level
    };

    statusOut.textContent = "distilling...";
    const data = await postJSON("/api/level-recipe", payload);
    statusOut.textContent = "ok";
    return data.recipe;
  }

  async function loadLevel() {
    // IMPORTANT: Single-flight prevents multiple calls (load + button + retries)
    const recipe = await singleFlight(`level-recipe:${runSeed}:${questId}:${level}`, fetchLevelRecipe)
      .catch((e) => {
        if (e.status === 429) {
          const ms = (e.retryAfter ? e.retryAfter * 1000 : 20000);
          setCooldown(ms);
          statusOut.textContent = "rate-limited";
          showToast("Rate limited. Using fallback level.");
        } else {
          statusOut.textContent = "recipe error";
          showToast("Recipe error. Using fallback level.");
        }
        console.warn(e, e.detailText);
        // fallback recipe
        return {
          version:"fallback",
          title:"Fallback Level",
          lore:"Server is cranky. Brew locally.",
          difficulty: Math.min(7, 2 + Math.floor(level/2)),
          colors: 5,
          bottleCount: 10,
          capacity: 4,
          emptyBottles: 2,
          lockedBottles: 0,
          wildcardSlots: 0,
          elements:["Au","Fe","Na","Cl","C"],
          sinTags:["indecision"],
          bonuses:[],
          constraints:[]
        };
      });

    buildBoardFromRecipe(recipe);
    render();
  }

  function nextLevel() {
    level++;
    questId = Math.ceil(level/4);
    sig.moves = 0;
    sig.invalid = 0;
    sig.moveTimes = [];
    sig.lastMoveAt = 0;
    loadLevel();
  }

  function resetRun() {
    sig.resets++;
    resetOut.textContent = String(sig.resets);
    runSeed = Math.floor(Math.random() * 1e9);
    level = 1;
    questId = 1;
    sig.moves = 0; sig.invalid = 0; sig.moveTimes = []; sig.lastMoveAt = 0;
    loadLevel();
    showToast("Run reset");
  }

  document.getElementById("btnNext").addEventListener("click", () => nextLevel());
  document.getElementById("btnReset").addEventListener("click", () => resetRun());

  // Initial load: only ONE call (level recipe). Quest node is manual.
  loadLevel();

</script>
</body>
</html>
