<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Marketing Alchemist â€” Bottle Fill (Quest DM)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f14; color:#e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; display:flex; flex-direction:column; gap:14px; }
    .card { border:1px solid #243244; border-radius: 18px; background: linear-gradient(180deg,#0f1724,#0b121c); box-shadow: 0 20px 50px rgba(0,0,0,.25); overflow:hidden; }
    .cardHeader { display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid #1e2a3c; }
    .title { font-size: 32px; font-weight: 900; letter-spacing: -0.5px; display:flex; align-items:center; gap:10px;}
    .pill { border:1px solid #243244; border-radius: 999px; padding: 8px 12px; background:#0b121c; display:inline-flex; align-items:center; gap:10px; }
    .pill input { width: 360px; max-width: 56vw; background: transparent; border: none; outline: none; color:#e6edf3; font: inherit; }
    button { cursor:pointer; border:1px solid #243244; background:#111a27; color:#e6edf3; border-radius: 14px; padding: 10px 14px; font-weight: 800; }
    button:disabled { opacity: .55; cursor:not-allowed; }
    .content { padding: 18px 16px; }
    h2 { margin: 0 0 10px 0; font-size: 34px; letter-spacing: -0.5px; }
    p { margin: 0 0 10px 0; font-size: 20px; line-height: 1.25; color:#d7deea; }
    .metaRow { display:flex; flex-wrap:wrap; gap:10px; margin-top:14px; }
    .meta { display:inline-flex; align-items:center; gap:10px; border:1px solid #243244; border-radius: 999px; padding: 10px 12px; background:#0b121c; font-size: 16px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 14px; color:#aab6ca; }
    .split { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .gameHeader { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .stats { display:flex; gap:10px; flex-wrap:wrap; }
    .grid { display:flex; flex-wrap:wrap; gap:16px; padding: 18px 16px; min-height: 300px; }
    .bottle {
      width: 84px; height: 220px;
      border-radius: 22px 22px 26px 26px;
      border: 2px solid rgba(220,232,255,.14);
      background: rgba(0,0,0,.25);
      position:relative;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.03);
      display:flex; flex-direction:column-reverse;
      overflow:hidden;
      user-select:none;
      touch-action: manipulation;
      transform: translateZ(0);
    }
    .bottle::before {
      content:"";
      position:absolute; inset: 10px 10px 10px 10px;
      border-radius: 18px 18px 22px 22px;
      border:1px solid rgba(255,255,255,.06);
      pointer-events:none;
    }
    .bottle.selected { outline: 3px solid rgba(130, 210, 255,.45); box-shadow: 0 0 0 6px rgba(80,140,255,.12), inset 0 0 0 2px rgba(255,255,255,.04); }
    .seg { width:100%; height: 22%; }
    .controls { display:flex; gap:10px; padding: 0 16px 16px 16px; flex-wrap:wrap; align-items:center;}
    .toast { position: fixed; left: 50%; bottom: 22px; transform: translateX(-50%); background:#0b121c; border:1px solid #243244; border-radius: 999px; padding: 10px 14px; font-weight:800; opacity:0; transition: opacity .18s ease; pointer-events:none;}
    .toast.show { opacity:1; }
    .pourFX {
      position: fixed; width: 10px; height: 10px; border-radius: 999px;
      pointer-events:none;
      opacity:0;
      transform: translate(-50%, -50%);
      filter: blur(.2px);
    }
    .dmStatus {
      margin-top: 2px;
      color:#aab6ca;
      font-size: 14px;
      line-height: 1.2;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- DM / Quest Card -->
    <div class="card" id="dmCard">
      <div class="cardHeader">
        <div class="title">ðŸ§ª The Marketing Alchemist <span style="opacity:.7">(Quest DM)</span></div>
        <div class="split">
          <div class="pill">
            <span style="opacity:.7">API:</span>
            <input id="apiBase" class="mono" />
          </div>
          <button id="btnQuest">DM</button>
        </div>
      </div>

      <div class="content">
        <h2 id="questTitle">â€”</h2>

        <!-- âœ… DM dialogue lives here -->
        <p id="dmIntro"></p>

        <!-- âœ… Scheduling / system copy lives here (no more overwriting dmIntro) -->
        <p id="dmStatus" class="dmStatus"></p>

        <p id="dmMid" class="small"></p>
        <p id="dmVerdict" class="small"></p>

        <div class="metaRow">
          <div class="meta">BANK: <span id="bankOut" class="mono">â€”</span></div>
          <div class="meta">SinTags: <span id="sinsOut" class="mono">â€”</span></div>
          <div class="meta">DM#: <span id="dmCountOut" class="mono">0</span> <span class="small">(major on #5, #10...)</span></div>
          <div class="meta">Next DM: <span id="nextDmOut" class="mono">â€”</span></div>
          <div class="meta">Modifier: <span id="modOut" class="mono">â€”</span></div>
          <div class="meta">Recipe: <span id="recipeSrcOut" class="mono">â€”</span></div>
          <div class="meta">Status: <span id="statusOut" class="mono">ready</span></div>
        </div>
      </div>
    </div>

    <!-- Game Card -->
    <div class="card">
      <div class="cardHeader gameHeader">
        <div class="title" style="font-size:26px">Bottle Fill</div>
        <div class="stats">
          <div class="meta">Level: <span id="levelOut" class="mono">1</span></div>
          <div class="meta">Moves: <span id="movesOut" class="mono">0</span></div>
          <div class="meta">Invalid: <span id="badOut" class="mono">0</span></div>
          <div class="meta">Resets: <span id="resetOut" class="mono">0</span></div>
          <div class="meta">Cfg: <span id="cfgOut" class="mono">â€”</span></div>
          <div class="meta small">Tap bottle â†’ tap target.</div>
        </div>
      </div>

      <div class="grid" id="grid"></div>

      <div class="controls">
        <button id="btnNext">Next Level</button>
        <button id="btnReset">Reset Run</button>
        <span class="small">Filler levels are deterministic. DM visits are seeded + persisted per run.</span>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="pourFX" id="pourFX"></div>

<script type="module">
  const DEFAULT_PROD = "https://ma-bottle-fill-api.onrender.com";
  const DEFAULT_LOCAL = "http://localhost:8787";
  const isLocal = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  const apiBaseEl = document.getElementById("apiBase");
  apiBaseEl.value = isLocal ? DEFAULT_LOCAL : DEFAULT_PROD;

  // ---------- Utilities ----------
  const inflight = new Map();
  function singleFlight(key, fn) {
    if (inflight.has(key)) return inflight.get(key);
    const p = (async () => { try { return await fn(); } finally { inflight.delete(key); } })();
    inflight.set(key, p);
    return p;
  }

  async function postJSON(path, body) {
    const base = apiBaseEl.value.trim().replace(/\/+$/, "");
    const url = base + path;
    const r = await fetch(url, { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body) });
    if (!r.ok) {
      let detailText = "";
      try { detailText = await r.text(); } catch {}
      const retryAfter = r.headers.get("Retry-After");
      const err = new Error(`${r.status} ${r.statusText}${retryAfter ? ` (Retry-After: ${retryAfter}s)` : ""}`);
      err.status = r.status;
      err.retryAfter = retryAfter ? Number(retryAfter) : null;
      err.detailText = detailText;
      throw err;
    }
    return await r.json();
  }

  const toast = document.getElementById("toast");
  function showToast(msg) {
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(()=>toast.classList.remove("show"), 1400);
  }

  function mulberry32(a) {
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }
  function hashSeed(a,b,c){
    let x = (a|0) ^ ((b|0)*0x9E3779B1) ^ ((c|0)*0x85EBCA77);
    x = Math.imul(x ^ (x>>>16), 0x7feb352d);
    x = Math.imul(x ^ (x>>>15), 0x846ca68b);
    x = x ^ (x>>>16);
    return x >>> 0;
  }
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));
  function randInt(min, max, seed) {
    const r = mulberry32(seed)();
    return Math.floor(r * (max - min + 1)) + min;
  }

  // ---------- DOM ----------
  const statusOut = document.getElementById("statusOut");
  const questTitle = document.getElementById("questTitle");
  const dmIntro = document.getElementById("dmIntro");
  const dmStatus = document.getElementById("dmStatus");
  const dmMid = document.getElementById("dmMid");
  const dmVerdict = document.getElementById("dmVerdict");
  const bankOut = document.getElementById("bankOut");
  const sinsOut = document.getElementById("sinsOut");
  const modOut = document.getElementById("modOut");
  const cfgOut = document.getElementById("cfgOut");
  const recipeSrcOut = document.getElementById("recipeSrcOut");
  const dmCountOut = document.getElementById("dmCountOut");
  const nextDmOut = document.getElementById("nextDmOut");

  const btnQuest = document.getElementById("btnQuest");
  const btnNext = document.getElementById("btnNext");
  const btnReset = document.getElementById("btnReset");

  const grid = document.getElementById("grid");
  const levelOut = document.getElementById("levelOut");
  const movesOut = document.getElementById("movesOut");
  const badOut = document.getElementById("badOut");
  const resetOut = document.getElementById("resetOut");
  const pourFX = document.getElementById("pourFX");

  // ---------- Game / Run State ----------
  const PALETTE = ["#00D1FF","#FF4D6D","#FFD400","#7CFF6B","#A855F7","#FF8A00","#00FFA8","#2E5BFF","#FF3DF2","#C2FF00"];

  let level = 1;
  let questId = 1;

  const sig = { moves:0, invalid:0, resets:0, moveTimes:[], lastMoveAt:0 };
  const avg = (arr)=> arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;

  function inferBANK() {
    const pace = avg(sig.moveTimes.slice(-12));
    const invalidRate = sig.moves ? (sig.invalid / sig.moves) : 0;
    const resetRate = sig.resets ? (sig.resets / Math.max(1, level)) : 0;

    const score = { B:0, A:0, N:0, K:0 };
    score.B += pace > 1400 ? 1.2 : 0;
    score.B += invalidRate < 0.10 ? 1.0 : 0;

    score.A += pace && pace < 900 ? 1.2 : 0;
    score.A += invalidRate < 0.22 ? 0.5 : 0;

    score.N += resetRate > 0.30 ? 1.0 : 0;
    score.N += invalidRate > 0.18 ? 0.6 : 0;

    score.K += invalidRate > 0.12 ? 0.7 : 0;
    score.K += resetRate < 0.25 ? 0.7 : 0;

    const entries = Object.entries(score).sort((a,b)=>b[1]-a[1]);
    const [bankPrimary, top] = entries[0];
    const second = entries[1][1];
    const conf = Math.max(0.25, Math.min(0.92, 0.35 + (top-second)*0.55));
    return { bankPrimary, bankConfidence: Number(conf.toFixed(2)) };
  }

  function inferSinTags() {
    const tags = [];
    if (sig.resets >= 2 && sig.resets > level/2) tags.push("over_reset");
    const pace = avg(sig.moveTimes.slice(-12));
    if (pace > 1500) tags.push("hesitation");
    if ((sig.moves && sig.invalid/sig.moves > 0.18)) tags.push("indecision");
    if (!tags.length) tags.push("steady_hand");
    return tags.slice(0,3);
  }

  let pendingModifier = null;
  function formatMod(mod) {
    if (!mod) return "â€”";
    const parts = [];
    const map = [
      ["bottleCountDelta","bottles"],
      ["colorsDelta","colors"],
      ["capacityDelta","cap"],
      ["emptyBottlesDelta","empty"],
      ["lockedBottlesDelta","locks"],
      ["wildcardSlotsDelta","wild"],
    ];
    for (const [k,label] of map) {
      const v = mod[k] ?? 0;
      if (v) parts.push(`${label}${v>0?"+":""}${v}`);
    }
    const tag = mod.ruleTag && mod.ruleTag !== "none" ? mod.ruleTag : "";
    return (parts.length ? parts.join(" ") : "no-delta") + (tag ? ` | ${tag}` : "");
  }
  function setPendingModifier(mod) {
    pendingModifier = mod;
    modOut.textContent = formatMod(mod);
  }

  // ---------- DM Scheduling ----------
  const DM_GAP_MIN = 3;
  const DM_GAP_MAX = 6;
  const DM_MAJOR_EVERY = 5;

  function loadOrInitRunState() {
    let runSeed = Number(localStorage.getItem("ma_runSeed") || "0");
    if (!runSeed) {
      runSeed = Math.floor(Math.random() * 1e9);
      localStorage.setItem("ma_runSeed", String(runSeed));
    }

    let dmAppearCount = Number(localStorage.getItem("ma_dmAppearCount") || "0");
    let nextDMAtLevel = Number(localStorage.getItem("ma_nextDMAtLevel") || "0");

    if (!nextDMAtLevel) {
      nextDMAtLevel = 1 + randInt(DM_GAP_MIN, DM_GAP_MAX, hashSeed(runSeed, 111, 222));
      localStorage.setItem("ma_nextDMAtLevel", String(nextDMAtLevel));
    }

    return { runSeed, dmAppearCount, nextDMAtLevel };
  }

  let { runSeed, dmAppearCount, nextDMAtLevel } = loadOrInitRunState();

  function isDMLevel(lvl) { return lvl === nextDMAtLevel; }
  function isMajorDM(upcomingCount) { return (upcomingCount % DM_MAJOR_EVERY) === 0; }

  function scheduleNextDM(currentLevel) {
    const gap = randInt(DM_GAP_MIN, DM_GAP_MAX, hashSeed(runSeed, dmAppearCount * 97, currentLevel * 131));
    nextDMAtLevel = currentLevel + gap;
    localStorage.setItem("ma_nextDMAtLevel", String(nextDMAtLevel));
  }

  function updateDMButton() {
    dmCountOut.textContent = String(dmAppearCount);
    nextDmOut.textContent = `L${nextDMAtLevel}`;

    if (isDMLevel(level)) {
      const upcoming = dmAppearCount + 1;
      const major = isMajorDM(upcoming);
      btnQuest.disabled = false;
      btnQuest.textContent = major ? "Major Ritual (Brew Modifier)" : "DM Speaks (No Modifier)";

      // âœ… IMPORTANT: schedule text goes to dmStatus, NOT dmIntro
      dmStatus.textContent = major
        ? "A major ritual is available now. Brew a modifier that affects the NEXT level."
        : "Minor DM visit. Story + directive only. No modifier brewed this time.";
    } else {
      btnQuest.disabled = true;
      btnQuest.textContent = `DM @ L${nextDMAtLevel}`;
      dmStatus.textContent =
        `DM appears randomly every ${DM_GAP_MIN}â€“${DM_GAP_MAX} levels. ` +
        `Next appearance: level ${nextDMAtLevel}. ` +
        `Modifiers only brew on every ${DM_MAJOR_EVERY}th DM appearance.`;
    }
  }

  // ---------- DM Render (FIXED) ----------
  function renderDM(payload) {
    questTitle.textContent = payload.quest_title || "â€”";

    // âœ… FIX: actually show dm_intro
    dmIntro.textContent = payload.dm_intro || "";

    dmMid.textContent = payload.dm_midpoint || "";
    dmVerdict.textContent = payload.dm_verdict || "";
  }

  // ---------- DM Click ----------
  btnQuest.addEventListener("click", async () => {
    if (!isDMLevel(level)) return;

    const { bankPrimary, bankConfidence } = inferBANK();
    const sinTags = inferSinTags();

    bankOut.textContent = `${bankPrimary} (${Math.round(bankConfidence*100)}%)`;
    sinsOut.textContent = sinTags.length ? sinTags.join(", ") : "â€”";

    const upcoming = dmAppearCount + 1;
    const wantModifier = isMajorDM(upcoming);

    statusOut.textContent = wantModifier ? "brewing..." : "speaking...";

    const payload = {
      act: Math.ceil(level/5),
      questId,
      bankPrimary,
      bankConfidence,
      sinTags,
      seed: runSeed,
      level,
      wantModifier
    };

    try {
      const key = `quest-node:${runSeed}:${questId}:${level}:${upcoming}:${wantModifier}`;
      const data = await singleFlight(key, () => postJSON("/api/quest-node", payload));
      const q = data.payload;

      renderDM(q);

      if (wantModifier) {
        setPendingModifier(q.modifier);
        showToast("Modifier brewed for next level");
      } else {
        setPendingModifier(null);
        showToast("DM visit (no modifier)");
      }

      dmAppearCount = upcoming;
      localStorage.setItem("ma_dmAppearCount", String(dmAppearCount));
      scheduleNextDM(level);
      updateDMButton();

      statusOut.textContent = "ok";
    } catch (e) {
      if (e.status === 429) {
        statusOut.textContent = "rate-limited";
        showToast("Rate limited. Try again soon.");
      } else {
        statusOut.textContent = "dm error";
        showToast("DM error (check server).");
      }
      console.warn(e, e.detailText);
    }
  });

  // ---------- Bottle Game (unchanged mechanics, kept stable) ----------
  const state = { bottles:[], capacity:4, selected:-1 };

  function isSolved() {
    return state.bottles.every(b => {
      if (b.length === 0) return true;
      if (b.length !== state.capacity) return false;
      return b.every(x => x === b[0]);
    });
  }
  const topColor = (b)=> b.length ? b[b.length-1] : null;
  function topRunCount(b){
    if (!b.length) return 0;
    const c = topColor(b);
    let n=0; for(let i=b.length-1;i>=0;i--){ if (b[i]===c) n++; else break; }
    return n;
  }
  function canPour(from,to){
    if (from===to) return false;
    const a=state.bottles[from], b=state.bottles[to];
    if (!a.length) return false;
    if (b.length>=state.capacity) return false;
    const color=topColor(a), target=topColor(b);
    return (target===null || target===color);
  }

  function bottleCenter(i){
    const el=document.querySelector(`[data-bottle="${i}"]`);
    if(!el) return {x:innerWidth/2,y:innerHeight/2};
    const r=el.getBoundingClientRect();
    return {x:r.left+r.width/2, y:r.top+r.height/4};
  }
  function playPourFX(from,to,color,amount){
    const a=bottleCenter(from), b=bottleCenter(to);
    pourFX.style.background=color;
    pourFX.style.opacity="1";
    pourFX.style.left=a.x+"px"; pourFX.style.top=a.y+"px";
    const dx=b.x-a.x, dy=b.y-a.y;
    const dur=Math.max(260, Math.min(580, 220+amount*90));
    pourFX.animate([
      { transform:"translate(-50%,-50%) scale(1)", opacity:0.9 },
      { transform:`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.9)`, opacity:0.85 },
      { transform:`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.7)`, opacity:0.0 }
    ], { duration:dur, easing:"cubic-bezier(.2,.8,.2,1)" });
    setTimeout(()=> pourFX.style.opacity="0", dur);
  }

  function doPour(from,to){
    if(!canPour(from,to)){
      sig.invalid++; badOut.textContent=String(sig.invalid);
      showToast("Invalid pour");
      return false;
    }
    const a=state.bottles[from], b=state.bottles[to];
    const color=topColor(a);
    const run=topRunCount(a);
    const space=state.capacity-b.length;
    const amount=Math.min(run,space);

    const now=performance.now();
    if(sig.lastMoveAt) sig.moveTimes.push(now-sig.lastMoveAt);
    sig.lastMoveAt=now;

    playPourFX(from,to,PALETTE[color%PALETTE.length], amount);
    for(let i=0;i<amount;i++) b.push(a.pop());

    sig.moves++; movesOut.textContent=String(sig.moves);
    render();

    if(isSolved()){
      showToast("Solved! Next levelâ€¦");
      setTimeout(()=>nextLevel(), 650);
    }
    return true;
  }

  const countEmpty = ()=> state.bottles.filter(b=>b.length===0).length;

  function shuffle(arr, rnd=Math.random){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(rnd()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  // Minimal local filler recipe (kept from your current approach)
  let anchorRecipe = null;
  function makeFillerRecipe() {
    const { bankPrimary } = inferBANK();
    const sinTags = inferSinTags();
    const seed = hashSeed(runSeed, level, questId);
    const rnd = mulberry32(seed);

    const targetDifficulty = clamp(1 + Math.floor(level / 3) + Math.floor(rnd()*2), 1, 10);

    const base = anchorRecipe ? structuredClone(anchorRecipe) : {
      version: "local-filler",
      title: "Filler Brew",
      lore: "A controlled run. No theatrics. Just results.",
      difficulty: targetDifficulty,
      colors: 5,
      bottleCount: 10,
      capacity: 4,
      emptyBottles: 2,
      lockedBottles: 0,
      wildcardSlots: 0,
      elements: ["Au","Fe","Na","Cl","C"],
      sinTags: [],
      bonuses: [],
      constraints: [],
      appliedModifier: {
        lockedBottlesDelta:0, emptyBottlesDelta:0, capacityDelta:0,
        wildcardSlotsDelta:0, colorsDelta:0, bottleCountDelta:0,
        ruleTag:"none", bonusObjective:""
      }
    };

    const wobble = (v, min, max, step=1) => clamp(v + (rnd()<0.33?-step:(rnd()>0.66?step:0)), min, max);
    base.version = "local-filler";
    base.difficulty = targetDifficulty;
    base.colors = wobble(clamp(4 + Math.floor(level/4), 4, 10), 4, 10, 1);
    base.capacity = wobble(4 + (level>=18?1:0) + (level>=32?1:0), 3, 6, 1);
    base.emptyBottles = clamp(2 + (rnd()<0.2?1:0) - (rnd()>0.9?1:0), 1, 6);
    base.bottleCount = clamp(base.colors + base.emptyBottles + 3 + Math.floor(rnd()*2), 6, 14);
    base.lockedBottles = clamp((level>=20?1:0) + (rnd()<0.08?1:0), 0, 3);
    base.wildcardSlots = clamp((level>=25 && rnd()<0.15)?1:0, 0, 2);

    base.sinTags = sinTags;
    base.title = `Filler: ${bankPrimary} Distillation`;
    base.lore = `You want drama. The lab wants precision. Pour cleaner.`;

    const pool = ["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Fe","Cu","Zn","Ag","Au"];
    const start = Math.floor(rnd()* (pool.length - base.colors));
    base.elements = pool.slice(start, start + base.colors);

    return base;
  }

  function buildBoardFromRecipe(recipe){
    const colors=recipe.colors, bottles=recipe.bottleCount, cap=recipe.capacity, empty=recipe.emptyBottles;
    const rnd = mulberry32(hashSeed(runSeed, level, 1337));

    const colorStacks=[];
    for(let c=0;c<colors;c++) colorStacks.push(Array.from({length:cap}, ()=>c));

    const pool=shuffle(colorStacks.flat(), rnd);
    const board=Array.from({length:bottles}, ()=>[]);
    const fillCount=bottles-empty;
    let idx=0;
    for(let b=0;b<fillCount;b++){
      for(let s=0;s<cap;s++){
        if(idx<pool.length) board[b].push(pool[idx++]);
      }
    }

    state.capacity=cap;
    state.bottles=board;
    state.selected=-1;

    const scramble = Math.max(40, Math.min(260, recipe.difficulty*24 + 60));
    for(let k=0;k<scramble;k++){
      const a=Math.floor(rnd()*bottles);
      const t=Math.floor(rnd()*bottles);
      if(a===t) continue;
      if(!canPour(a,t)) continue;
      const from=state.bottles[a], to=state.bottles[t];
      if(!from.length || to.length>=cap) continue;
      const col=topColor(from), tgt=topColor(to);
      if(tgt!==null && tgt!==col) continue;
      to.push(from.pop());
    }
  }

  function nextLevel(){
    level += 1;
    const recipe = makeFillerRecipe();
    buildBoardFromRecipe(recipe);
    recipeSrcOut.textContent = recipe.version || "local";
    render();
  }

  function resetRun(){
    localStorage.removeItem("ma_runSeed");
    localStorage.removeItem("ma_dmAppearCount");
    localStorage.removeItem("ma_nextDMAtLevel");
    location.reload();
  }

  function render(){
    grid.innerHTML="";
    state.bottles.forEach((b,i)=>{
      const bottle=document.createElement("div");
      bottle.className="bottle"+(state.selected===i?" selected":"");
      bottle.dataset.bottle=String(i);

      for(let s=0;s<state.capacity;s++){
        const seg=document.createElement("div");
        seg.className="seg";
        const ci = b[s] ?? null;
        seg.style.background = (ci===null) ? "transparent" : PALETTE[ci%PALETTE.length];
        bottle.appendChild(seg);
      }

      bottle.addEventListener("click", ()=>{
        if(state.selected===-1){ state.selected=i; render(); return; }
        if(state.selected===i){ state.selected=-1; render(); return; }
        const success=doPour(state.selected,i);
        state.selected=-1;
        if(!success) render();
      });

      grid.appendChild(bottle);
    });

    levelOut.textContent=String(level);
    movesOut.textContent=String(sig.moves);
    badOut.textContent=String(sig.invalid);
    resetOut.textContent=String(sig.resets);
    cfgOut.textContent=`b${state.bottles.length}/c${state.capacity}/e${countEmpty()}`;
    updateDMButton();
  }

  btnNext.addEventListener("click", nextLevel);
  btnReset.addEventListener("click", ()=>{
    sig.resets++; resetOut.textContent=String(sig.resets);
    showToast("Run reset");
    resetRun();
  });

  // Boot
  dmIntro.textContent = ""; // dialogue slot starts empty
  updateDMButton();
  nextLevel();
</script>
</body>
</html>
