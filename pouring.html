<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Canvas Fluid Pour Demo (Gravity + Slosh)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0f14;display:grid;place-items:center;}
    .wrap{display:flex;flex-direction:column;gap:12px;align-items:center}
    canvas{background:#0f1620;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.6);}
    button{
      font: 14px system-ui,-apple-system,Segoe UI,Roboto,Arial;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#e6eefc;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
    }
    button:active{background:rgba(255,255,255,.10)}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="900" height="520"></canvas>
    <button id="restart">Restart Pour</button>
  </div>

<script>
(() => {
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  const TAU = Math.PI * 2;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const easeInOut = t => t<.5 ? 2*t*t : 1-(-2*t+2)**2/2;

  // Bottle model (simple rounded test tube)
  function makeBottle(x,y,w,h){
    return {
      x,y,w,h,
      angle: 0,             // radians
      fill: 0.72,           // 0..1 (height fraction)
      color: "#18c38b",
      slosh: { v: 0, p: 0 }, // damped oscillator state
      _angleVel: 0
    };
  }

  // Convert a local bottle-space point to world coords
  function toWorld(b, lx, ly){
    const cos = Math.cos(b.angle), sin = Math.sin(b.angle);
    return {
      x: b.x + lx*cos - ly*sin,
      y: b.y + lx*sin + ly*cos
    };
  }

  // Define spout + mouth points using consistent local coords
  function spoutPointWorld(b){
    // top-right rim area (tweak if you want)
    return toWorld(b,  b.w*0.22, -b.h*0.46);
  }
  function mouthPointWorld(b){
    // top-left rim area (tweak if you want)
    return toWorld(b, -b.w*0.22, -b.h*0.46);
  }

  // Drawing transforms
  function withBottleTransform(b, fn){
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);
    fn();
    ctx.restore();
  }

  // Bottle outline path (local coords centered)
  function bottlePath(b){
    const w=b.w, h=b.h;
    const r = Math.min(w*0.20, 22);
    const neckH = h*0.10;
    const neckW = w*0.58;

    const x0 = -w/2, y0 = -h/2;
    const x1 =  w/2, y1 =  h/2;

    ctx.beginPath();
    ctx.moveTo(-neckW/2, y0);
    ctx.lineTo( neckW/2, y0);
    ctx.quadraticCurveTo( w/2, y0, x1, y0+neckH);
    ctx.lineTo(x1, y1 - r);
    ctx.quadraticCurveTo(x1, y1, x1-r, y1);
    ctx.lineTo(x0+r, y1);
    ctx.quadraticCurveTo(x0, y1, x0, y1-r);
    ctx.lineTo(x0, y0+neckH);
    ctx.quadraticCurveTo(-w/2, y0, -neckW/2, y0);
    ctx.closePath();
  }

  // Liquid inside bottle with “gravity-level surface” + slosh
  function drawLiquid(b){
    const w=b.w, h=b.h;
    const padX = w*0.10;
    const padTop = h*0.08;
    const padBot = h*0.06;

    const innerLeft  = -w/2 + padX;
    const innerRight =  w/2 - padX;
    const innerTop   = -h/2 + padTop;
    const innerBot   =  h/2 - padBot;

    // Base fill height
    const fillY = lerp(innerBot, innerTop, b.fill);

    // Gravity direction in local space
    const gx =  Math.sin(b.angle);
    const gy =  Math.cos(b.angle);

    // Surface slope from gravity
    let m = 0;
    if (Math.abs(gy) > 1e-4) m = -gx/gy;
    m = clamp(m, -2.2, 2.2);

    // Slosh
    const sloshAmp = 10;      // px
    const slopeAmp = 0.25;    // subtle tilt coupling
    const wave = b.slosh.p;

    const k = fillY + sloshAmp * wave;

    const xL = innerLeft;
    const xR = innerRight;
    let yL = m*xL + k + slopeAmp*wave*(xL/(w/2))*18;
    let yR = m*xR + k + slopeAmp*wave*(xR/(w/2))*18;

    yL = clamp(yL, innerTop, innerBot);
    yR = clamp(yR, innerTop, innerBot);

    ctx.save();
    bottlePath(b);
    ctx.clip();

    // liquid fill
    ctx.beginPath();
    ctx.moveTo(xL, yL);
    ctx.lineTo(xR, yR);
    ctx.lineTo(xR, innerBot);
    ctx.lineTo(xL, innerBot);
    ctx.closePath();

    ctx.fillStyle = b.color;
    ctx.globalAlpha = 0.92;
    ctx.fill();

    // refraction highlight
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(innerLeft + 10, innerTop, 12, innerBot-innerTop);

    // surface sheen
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xL, yL);
    ctx.lineTo(xR, yR);
    ctx.stroke();

    ctx.restore();
    ctx.restore();
  }

  function drawBottle(b){
    withBottleTransform(b, ()=>{
      bottlePath(b);
      ctx.fillStyle = "rgba(255,255,255,0.03)";
      ctx.fill();

      drawLiquid(b);

      bottlePath(b);
      ctx.strokeStyle = "rgba(220,230,255,0.55)";
      ctx.lineWidth = 3;
      ctx.stroke();

      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.lineWidth = 6;
      ctx.stroke();
    });
  }

  function isPouring(b){
    return Math.abs(b.angle) > 0.25; // ~14°
  }

  function drawStream(a, b, color, strength){
    if (strength <= 0) return;

    const s = spoutPointWorld(a);
    const m = mouthPointWorld(b);

    const midX = (s.x + m.x)/2;
    const midY = Math.max(s.y, m.y) + 130; // sag downward

    ctx.save();
    ctx.globalAlpha = 0.85 * strength;
    ctx.strokeStyle = color;
    ctx.lineWidth = lerp(2, 10, strength);
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.quadraticCurveTo(midX, midY, m.x, m.y);
    ctx.stroke();

    // droplets
    ctx.globalAlpha = 0.35 * strength;
    for (let i=0;i<3;i++){
      const px = lerp(s.x, m.x, 0.35 + i*0.18);
      const py = lerp(s.y, m.y, 0.35 + i*0.18) + 22 + i*18;
      ctx.beginPath();
      ctx.arc(px + (Math.random()-0.5)*6, py + (Math.random()-0.5)*6, 2.2, 0, TAU);
      ctx.fillStyle = color;
      ctx.fill();
    }

    ctx.restore();
  }

  // Damped slosh oscillator
  function updateSlosh(b, dt){
    const stiffness = 18;
    const damping = 10;
    const input = clamp(b._angleVel || 0, -2, 2) * 0.55;

    b.slosh.v += (-stiffness*b.slosh.p - damping*b.slosh.v + input) * dt;
    b.slosh.p += b.slosh.v * dt;
    b.slosh.p = clamp(b.slosh.p, -1.2, 1.2);
  }

  // Scene objects
  let src, dst;
  let t, pouring;
  let last = performance.now();

  function reset(){
    // Centers, not top-left:
    src = makeBottle(260, 280, 120, 320);
    src.color = "#FFD300";
    src.fill  = 0.78;

    dst = makeBottle(640, 280, 120, 320);
    dst.color = "#00B3FF";
    dst.fill  = 0.18;

    t = 0;
    pouring = true;
    last = performance.now();
  }

  function tick(now){
    const dt = clamp((now-last)/1000, 0.0, 0.033);
    last = now;

    t += dt;

    // tilt in, pour, tilt out
    const tiltIn  = clamp(t/0.8, 0, 1);
    const pourMid = clamp((t-0.9)/1.6, 0, 1);
    const tiltOut = clamp((t-2.7)/0.9, 0, 1);

    const a0 = 0;
    const aTilt = -0.62; // ~ -35°
    let desired = a0;

    if (tiltIn < 1) desired = lerp(a0, aTilt, easeInOut(tiltIn));
    else if (tiltOut < 1) desired = aTilt;
    else desired = lerp(aTilt, a0, easeInOut(tiltOut));

    const prevA = src.angle;
    src.angle = desired;
    src._angleVel = (src.angle - prevA) / Math.max(dt, 1e-4);

    dst._angleVel = 0;

    updateSlosh(src, dt);
    updateSlosh(dst, dt);

    // flow
    let flowStrength = 0;
    if (pouring && isPouring(src) && pourMid > 0 && tiltOut === 0){
      const tiltFactor = clamp((Math.abs(src.angle)-0.22)/0.45, 0, 1);
      flowStrength = tiltFactor;

      const rate = 0.22; // fill fraction / sec at full flow
      const dFill = rate * flowStrength * dt;

      const canDrain = Math.max(0, src.fill - 0.08);
      const canFill  = Math.max(0, 0.92 - dst.fill);
      const actual = Math.min(dFill, canDrain, canFill);

      src.fill -= actual;
      dst.fill += actual;

      dst.slosh.v += actual * 30;
    }

    if (t > 3.9) pouring = false;

    // render
    ctx.clearRect(0,0,c.width,c.height);

    // vignette
    const g = ctx.createRadialGradient(c.width/2, c.height/2, 60, c.width/2, c.height/2, 520);
    g.addColorStop(0, "rgba(255,255,255,0.06)");
    g.addColorStop(1, "rgba(0,0,0,0.0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,c.width,c.height);

    ctx.fillStyle = "rgba(230,240,255,0.7)";
    ctx.font = "20px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText("Gravity-level surface + slosh + pour stream (Canvas Demo)", 24, 38);

    drawStream(src, dst, src.color, flowStrength);
    drawBottle(src);
    drawBottle(dst);

    requestAnimationFrame(tick);
  }

  document.getElementById("restart").addEventListener("click", reset);

  reset();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
